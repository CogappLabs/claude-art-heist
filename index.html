<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIC Art Heist</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: 'Courier New', monospace;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #game-canvas {
            border: 3px solid #e94560;
            background: #16213e;
        }

        #ui {
            color: #eee;
            font-size: 18px;
            display: flex;
            gap: 30px;
        }

        #instructions {
            color: #888;
            font-size: 14px;
            margin-top: 10px;
        }

        #game-over {
            display: none;
            position: absolute;
            color: #e94560;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #game-over.show {
            display: block;
        }

        #toast {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 15px 20px;
            max-width: 400px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        #toast.show {
            opacity: 1;
        }

        #toast .toast-title {
            color: #ffd700;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        #toast .toast-artist {
            color: #eee;
            font-size: 14px;
            margin-bottom: 4px;
        }

        #toast .toast-details {
            color: #888;
            font-size: 12px;
            line-height: 1.4;
        }

        #toast .toast-stolen {
            color: #e94560;
            font-size: 11px;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #finish-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.98);
            z-index: 100;
            overflow-y: auto;
            padding: 40px 20px;
        }

        #finish-screen.show {
            display: block;
        }

        #finish-screen .finish-header {
            text-align: center;
            margin-bottom: 30px;
        }

        #finish-screen .finish-title {
            color: #e94560;
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #finish-screen .finish-stats {
            color: #888;
            font-size: 18px;
        }

        #finish-screen .finish-stats span {
            color: #ffd700;
        }

        #finish-screen .loot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto 30px;
        }

        #finish-screen .loot-item {
            background: #16213e;
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            gap: 15px;
            text-decoration: none;
            transition: transform 0.2s, border-color 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }

        #finish-screen .loot-item:hover {
            transform: translateY(-3px);
            border-color: #fff;
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
        }

        #finish-screen .loot-image {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border: 2px solid #ffd700;
            flex-shrink: 0;
        }

        #finish-screen .loot-image-placeholder {
            width: 100px;
            height: 100px;
            background: #ffd700;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #16213e;
            font-weight: bold;
            flex-shrink: 0;
        }

        #finish-screen .loot-info {
            flex: 1;
            min-width: 0;
        }

        #finish-screen .loot-title {
            color: #ffd700;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        #finish-screen .loot-artist {
            color: #eee;
            font-size: 12px;
            margin-bottom: 4px;
        }

        #finish-screen .loot-details {
            color: #888;
            font-size: 11px;
            line-height: 1.4;
        }

        #finish-screen .loot-style {
            color: #e94560;
            font-size: 10px;
            margin-top: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #finish-screen .finish-instructions {
            text-align: center;
            color: #888;
            font-size: 14px;
            margin-bottom: 20px;
        }

        #finish-screen .highscore-section {
            max-width: 400px;
            margin: 0 auto 30px;
            background: #16213e;
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 15px;
        }

        #finish-screen .highscore-title {
            color: #ffd700;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
        }

        #finish-screen .highscore-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 150px;
            overflow-y: auto;
            position: relative;
            scroll-behavior: smooth;
        }
        #finish-screen .highscore-list::-webkit-scrollbar {
            width: 6px;
        }
        #finish-screen .highscore-list::-webkit-scrollbar-track {
            background: #1a1a2e;
            border-radius: 3px;
        }
        #finish-screen .highscore-list::-webkit-scrollbar-thumb {
            background: #ffd700;
            border-radius: 3px;
        }

        #finish-screen .highscore-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            font-size: 13px;
        }

        #finish-screen .highscore-item:last-child {
            border-bottom: none;
        }

        #finish-screen .highscore-rank {
            color: #888;
            width: 30px;
        }

        #finish-screen .highscore-name {
            color: #eee;
            flex: 1;
        }

        #finish-screen .highscore-score {
            color: #ffd700;
        }

        #finish-screen .highscore-item.current-player {
            background: rgba(255, 215, 0, 0.25);
            border-radius: 4px;
            padding: 5px 8px;
            margin: 2px -8px;
            border: 1px solid #ffd700;
            animation: highlight-pulse 1s ease-in-out 2;
        }
        @keyframes highlight-pulse {
            0%, 100% { background: rgba(255, 215, 0, 0.25); }
            50% { background: rgba(255, 215, 0, 0.4); }
        }

        #name-entry-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 300;
            align-items: center;
            justify-content: center;
        }

        #name-entry-modal.show {
            display: flex;
        }

        #name-entry-modal .modal-content {
            background: #16213e;
            border: 3px solid #ffd700;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
        }

        #name-entry-modal .modal-title {
            color: #ffd700;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #name-entry-modal .modal-subtitle {
            color: #eee;
            font-size: 16px;
            margin-bottom: 20px;
        }

        #name-entry-modal input {
            width: 100%;
            padding: 12px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            border: 2px solid #ffd700;
            border-radius: 6px;
            color: #fff;
            text-align: center;
            margin-bottom: 15px;
        }

        #name-entry-modal input:focus {
            outline: none;
            border-color: #fff;
        }

        #name-entry-modal .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        #name-entry-modal button {
            padding: 10px 25px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            border: 2px solid;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #name-entry-modal .submit-btn {
            background: #ffd700;
            border-color: #ffd700;
            color: #16213e;
        }

        #name-entry-modal .submit-btn:hover {
            background: #fff;
            border-color: #fff;
        }

        #name-entry-modal .skip-btn {
            background: transparent;
            border-color: #888;
            color: #888;
        }

        #name-entry-modal .skip-btn:hover {
            border-color: #eee;
            color: #eee;
        }

        #finish-screen .no-loot {
            text-align: center;
            color: #888;
            font-size: 18px;
            padding: 40px;
        }

        #splash-screen {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.98);
            z-index: 200;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #splash-screen.hidden {
            display: none;
        }

        #splash-screen .splash-title {
            color: #e94560;
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #splash-screen .splash-subtitle {
            color: #ffd700;
            font-size: 18px;
            margin-bottom: 30px;
        }

        #splash-screen .splash-section {
            max-width: 600px;
            width: 100%;
            margin-bottom: 25px;
        }

        #splash-screen .splash-section-title {
            color: #e94560;
            font-size: 16px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #splash-screen .splash-controls {
            color: #eee;
            font-size: 14px;
            line-height: 1.8;
        }

        #splash-screen .splash-powerups {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        #splash-screen .powerup-item {
            background: #16213e;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #splash-screen .powerup-icon {
            font-size: 24px;
            width: 36px;
            text-align: center;
        }

        #splash-screen .powerup-info {
            flex: 1;
        }

        #splash-screen .powerup-name {
            color: #ffd700;
            font-size: 13px;
            font-weight: bold;
        }

        #splash-screen .powerup-desc {
            color: #888;
            font-size: 11px;
        }

        #splash-screen .splash-start {
            color: #fff;
            font-size: 20px;
            margin-top: 20px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        #active-powerups {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
        }

        #config-panel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.98);
            z-index: 400;
            align-items: center;
            justify-content: center;
        }

        #config-panel.show {
            display: flex;
        }

        #config-panel .config-content {
            background: #16213e;
            border: 3px solid #ffd700;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }

        #config-panel .config-title {
            color: #ffd700;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }

        #config-panel .config-desc {
            color: #888;
            font-size: 14px;
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.5;
        }

        #config-panel .config-desc a {
            color: #ffd700;
        }

        #config-panel .config-field {
            margin-bottom: 15px;
        }

        #config-panel .config-field label {
            display: block;
            color: #eee;
            font-size: 14px;
            margin-bottom: 5px;
        }

        #config-panel .config-field input {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            border: 2px solid #444;
            border-radius: 6px;
            color: #fff;
        }

        #config-panel .config-field input:focus {
            outline: none;
            border-color: #ffd700;
        }

        #config-panel .config-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        #config-panel button {
            padding: 10px 25px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            border: 2px solid;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #config-panel .save-btn {
            background: #ffd700;
            border-color: #ffd700;
            color: #16213e;
        }

        #config-panel .save-btn:hover {
            background: #fff;
            border-color: #fff;
        }

        #config-panel .close-btn {
            background: transparent;
            border-color: #888;
            color: #888;
        }

        #config-panel .close-btn:hover {
            border-color: #eee;
            color: #eee;
        }

        #config-panel .config-status {
            text-align: center;
            margin-top: 15px;
            font-size: 13px;
        }

        #config-panel .config-status.success {
            color: #50fa7b;
        }

        #config-panel .config-status.error {
            color: #e94560;
        }

        .active-powerup {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffd700;
            border-radius: 6px;
            padding: 5px 10px;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .active-powerup .powerup-timer {
            color: #ffd700;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div id="ui">
            <span>Level: <span id="level">1</span></span>
            <span>Score: <span id="score">0</span></span>
            <span>Theme: <span id="theme">-</span></span>
        </div>
        <canvas id="game-canvas" width="800" height="500"></canvas>
        <div id="game-over">CAUGHT! Press R to restart</div>
        <div id="toast">
            <div class="toast-title"></div>
            <div class="toast-artist"></div>
            <div class="toast-details"></div>
            <div class="toast-stolen">STOLEN!</div>
        </div>
        <div id="instructions">Hold SPACE to go up | Release to go down | Collect art (+50) | Avoid guards | Press R to
            restart</div>
    </div>

    <div id="finish-screen">
        <div class="finish-header">
            <div class="finish-title">CAUGHT!</div>
            <div class="finish-stats">
                You reached level <span id="finish-level">1</span> and stole <span id="finish-count">0</span> artworks
                worth <span id="finish-score">0</span> points
            </div>
        </div>
        <div class="finish-instructions">Press R or triple-tap to restart, or tap on any artwork to find out more about
            it</div>
        <div class="highscore-section" id="highscore-section">
            <div class="highscore-title">LEADERBOARD</div>
            <ul class="highscore-list" id="highscore-list">
                <li class="highscore-item"><span class="highscore-name">Loading...</span></li>
            </ul>
        </div>
        <div class="loot-grid" id="loot-grid"></div>
    </div>

    <div id="splash-screen">
        <div class="splash-title">AIC ART HEIST</div>
        <div class="splash-subtitle">Steal priceless art. Avoid the guards.</div>

        <div class="splash-section">
            <div class="splash-section-title">Controls</div>
            <div class="splash-controls">
                <strong>SPACE</strong> or <strong>CLICK/TAP</strong> (hold) - Angle upward<br>
                <strong>Release</strong> - Angle downward<br>
                <strong>R</strong> - Restart game
            </div>
        </div>

        <div class="splash-section">
            <div class="splash-section-title">Power-ups</div>
            <div class="splash-powerups">
                <div class="powerup-item">
                    <div class="powerup-icon">üß≤</div>
                    <div class="powerup-info">
                        <div class="powerup-name">Magnet</div>
                        <div class="powerup-desc">Pulls nearby artworks toward you</div>
                    </div>
                </div>
                <div class="powerup-item">
                    <div class="powerup-icon">üéí</div>
                    <div class="powerup-info">
                        <div class="powerup-name">Bulk Heist</div>
                        <div class="powerup-desc">Instantly collect all nearby art</div>
                    </div>
                </div>
                <div class="powerup-item">
                    <div class="powerup-icon">üõ°Ô∏è</div>
                    <div class="powerup-info">
                        <div class="powerup-name">Shield</div>
                        <div class="powerup-desc">Survive one guard collision</div>
                    </div>
                </div>
                <div class="powerup-item">
                    <div class="powerup-icon">üí∞</div>
                    <div class="powerup-info">
                        <div class="powerup-name">Bribe</div>
                        <div class="powerup-desc">Turn nearest guard into artwork</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="splash-start">Press SPACE or TAP to start</div>
    </div>

    <div id="active-powerups"></div>

    <div id="name-entry-modal">
        <div class="modal-content">
            <div class="modal-title">HIGH SCORE!</div>
            <div class="modal-subtitle">You made the top 25! Enter your name:</div>
            <input type="text" id="player-name-input" maxlength="15" placeholder="Your name">
            <div class="modal-buttons">
                <button class="submit-btn" id="submit-name-btn">Submit</button>
                <button class="skip-btn" id="skip-name-btn">Skip</button>
            </div>
        </div>
    </div>

    <div id="config-panel">
        <div class="config-content">
            <div class="config-title">Leaderboard Setup</div>
            <div class="config-desc">
                Enter your Dreamlo codes to enable the global leaderboard.<br>
                Get free codes at <a href="https://dreamlo.com" target="_blank">dreamlo.com</a>
            </div>
            <div class="config-field">
                <label for="config-public">Public Code:</label>
                <input type="text" id="config-public" placeholder="Your public code">
            </div>
            <div class="config-field">
                <label for="config-private">Private Code:</label>
                <input type="text" id="config-private" placeholder="Your private code">
            </div>
            <div class="config-buttons">
                <button class="save-btn" id="config-save-btn">Save</button>
                <button class="close-btn" id="config-close-btn">Close</button>
            </div>
            <div class="config-status" id="config-status"></div>
        </div>
    </div>

    <script type="module">
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameOverEl = document.getElementById('game-over');
        const levelEl = document.getElementById('level');
        const scoreEl = document.getElementById('score');
        const themeEl = document.getElementById('theme');

        // Game state
        let gameState = {
            playerX: 0,
            playerY: 0,
            path: [],
            guards: [],
            artworks: [],
            powerups: [],
            goingUp: false,
            gameOver: false,
            gameStarted: false,
            level: 1,
            score: 0,
            speed: 3,
            artworksLoaded: false,
            currentStyle: null,
            usedStyles: [],
            stolenArtworks: [],
            // Active power-up states
            activePowerups: {
                magnet: { active: false, duration: 0 },
                shield: { active: false, count: 0 }
            }
        };

        // Dreamlo leaderboard configuration
        // Uses Vite env vars (from .env locally, GitHub secrets in CI)
        const DREAMLO_BASE_URL = 'https://www.dreamlo.com/lb';
        const BUILD_DREAMLO_PUBLIC = import.meta.env?.VITE_DREAMLO_PUBLIC_CODE || '';
        const BUILD_DREAMLO_PRIVATE = import.meta.env?.VITE_DREAMLO_PRIVATE_CODE || '';

        function getDreamloPublicCode() {
            return BUILD_DREAMLO_PUBLIC || localStorage.getItem('dreamlo_public_code') || '';
        }

        function getDreamloPrivateCode() {
            return BUILD_DREAMLO_PRIVATE || localStorage.getItem('dreamlo_private_code') || '';
        }

        function isDreamloConfigured() {
            return getDreamloPublicCode() && getDreamloPrivateCode();
        }

        function isUsingBuildConfig() {
            return BUILD_DREAMLO_PUBLIC && BUILD_DREAMLO_PRIVATE;
        }

        // Config panel functionality
        function showConfigPanel() {
            const panel = document.getElementById('config-panel');
            const publicInput = document.getElementById('config-public');
            const privateInput = document.getElementById('config-private');
            const statusEl = document.getElementById('config-status');

            // Load current values
            publicInput.value = getDreamloPublicCode();
            privateInput.value = getDreamloPrivateCode();
            statusEl.textContent = '';
            statusEl.className = 'config-status';

            panel.classList.add('show');
        }

        function hideConfigPanel() {
            document.getElementById('config-panel').classList.remove('show');
        }

        function initConfigPanel() {
            const saveBtn = document.getElementById('config-save-btn');
            const closeBtn = document.getElementById('config-close-btn');
            const publicInput = document.getElementById('config-public');
            const privateInput = document.getElementById('config-private');
            const statusEl = document.getElementById('config-status');

            saveBtn.addEventListener('click', async () => {
                const publicCode = publicInput.value.trim();
                const privateCode = privateInput.value.trim();

                if (!publicCode || !privateCode) {
                    statusEl.textContent = 'Please enter both codes';
                    statusEl.className = 'config-status error';
                    return;
                }

                // Save to localStorage
                localStorage.setItem('dreamlo_public_code', publicCode);
                localStorage.setItem('dreamlo_private_code', privateCode);

                // Test the connection
                statusEl.textContent = 'Testing connection...';
                statusEl.className = 'config-status';

                try {
                    const response = await fetch(`${DREAMLO_BASE_URL}/${publicCode}/json/1`);
                    if (response.ok) {
                        statusEl.textContent = 'Saved successfully!';
                        statusEl.className = 'config-status success';
                        // Refresh leaderboard cache
                        await fetchLeaderboard();
                        setTimeout(hideConfigPanel, 1500);
                    } else {
                        statusEl.textContent = 'Invalid public code';
                        statusEl.className = 'config-status error';
                    }
                } catch (error) {
                    statusEl.textContent = 'Connection failed - codes saved anyway';
                    statusEl.className = 'config-status error';
                }
            });

            closeBtn.addEventListener('click', hideConfigPanel);

            // Check URL parameter on load (only if build config not present)
            if (!isUsingBuildConfig()) {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('config') === 'true') {
                    showConfigPanel();
                }
            }
        }

        let leaderboardCache = null;
        let playerSubmittedScore = false;

        async function fetchLeaderboard() {
            const publicCode = getDreamloPublicCode();
            if (!publicCode) {
                return null; // Dreamlo not configured
            }
            try {
                const response = await fetch(`${DREAMLO_BASE_URL}/${publicCode}/json/25`);
                const data = await response.json();
                leaderboardCache = data.dreamlo?.leaderboard?.entry || [];
                // Ensure it's always an array (single entry comes as object)
                if (!Array.isArray(leaderboardCache)) {
                    leaderboardCache = [leaderboardCache];
                }
                return leaderboardCache;
            } catch (error) {
                console.error('Failed to fetch leaderboard:', error);
                return null;
            }
        }

        async function submitScore(name, score) {
            const privateCode = getDreamloPrivateCode();
            if (!privateCode) {
                return false; // Dreamlo not configured
            }
            try {
                const cleanName = name.replace(/[^a-zA-Z0-9]/g, '').substring(0, 15) || 'Anonymous';
                await fetch(`${DREAMLO_BASE_URL}/${privateCode}/add/${encodeURIComponent(cleanName)}/${score}`);
                playerSubmittedScore = true;
                // Wait a moment for Dreamlo to propagate the score
                await new Promise(resolve => setTimeout(resolve, 500));
                // Refresh leaderboard
                await fetchLeaderboard();
                return true;
            } catch (error) {
                console.error('Failed to submit score:', error);
                return false;
            }
        }

        function checkIfQualifiesForTop25(score) {
            if (!isDreamloConfigured()) {
                return false; // Can't qualify if leaderboard isn't set up
            }
            if (!leaderboardCache || leaderboardCache.length < 25) {
                return true; // Less than 25 entries, automatically qualifies
            }
            // Check if score beats the lowest in top 25
            const lowestScore = parseInt(leaderboardCache[leaderboardCache.length - 1]?.score || 0);
            return score > lowestScore;
        }

        function displayLeaderboard(playerScore = null) {
            const listEl = document.getElementById('highscore-list');
            const sectionEl = document.getElementById('highscore-section');

            if (!leaderboardCache || leaderboardCache.length === 0) {
                if (!isDreamloConfigured()) {
                    listEl.innerHTML = '<li class="highscore-item"><span class="highscore-name" style="color: #888;">Leaderboard not configured</span></li>';
                } else {
                    listEl.innerHTML = '<li class="highscore-item"><span class="highscore-name">No scores yet. Be the first!</span></li>';
                }
                return;
            }

            listEl.innerHTML = '';
            let currentPlayerEl = null;
            leaderboardCache.forEach((entry, index) => {
                const li = document.createElement('li');
                li.className = 'highscore-item';

                // Highlight if this might be the current player's score
                const entryScore = parseInt(entry.score);
                if (playerScore !== null && entryScore === playerScore && playerSubmittedScore && !currentPlayerEl) {
                    li.classList.add('current-player');
                    currentPlayerEl = li;
                }

                li.innerHTML = `
                    <span class="highscore-rank">${index + 1}.</span>
                    <span class="highscore-name">${entry.name}</span>
                    <span class="highscore-score">${entry.score}</span>
                `;
                listEl.appendChild(li);
            });

            // Scroll to the current player's entry after a brief delay
            if (currentPlayerEl) {
                setTimeout(() => {
                    currentPlayerEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        }

        function showNameEntryModal(score) {
            const modal = document.getElementById('name-entry-modal');
            const input = document.getElementById('player-name-input');
            const submitBtn = document.getElementById('submit-name-btn');
            const skipBtn = document.getElementById('skip-name-btn');

            modal.classList.add('show');
            input.value = '';
            input.focus();

            const handleSubmit = async () => {
                const name = input.value.trim() || 'Anonymous';
                modal.classList.remove('show');
                await submitScore(name, score);
                displayLeaderboard(score);
            };

            const handleSkip = () => {
                modal.classList.remove('show');
                displayLeaderboard(score);
            };

            // Remove old listeners and add new ones
            const newSubmitBtn = submitBtn.cloneNode(true);
            const newSkipBtn = skipBtn.cloneNode(true);
            submitBtn.parentNode.replaceChild(newSubmitBtn, submitBtn);
            skipBtn.parentNode.replaceChild(newSkipBtn, skipBtn);

            newSubmitBtn.addEventListener('click', handleSubmit);
            newSkipBtn.addEventListener('click', handleSkip);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') handleSubmit();
                if (e.key === 'Escape') handleSkip();
            });
        }

        // Power-up definitions
        const POWERUP_TYPES = {
            magnet: { icon: 'üß≤', name: 'Magnet', duration: 300 }, // 5 seconds at 60fps
            bulkHeist: { icon: 'üéí', name: 'Bulk Heist', radius: 150 },
            shield: { icon: 'üõ°Ô∏è', name: 'Shield' },
            bribe: { icon: 'üí∞', name: 'Bribe' }
        };
        const POWERUP_SIZE = 30;

        const finishScreenEl = document.getElementById('finish-screen');

        const GUARD_SIZE = 30;
        const GUARD_EMOJI = 'üëÆ';
        const ARTWORK_SIZE = 50;
        const MIN_ARTWORKS_PER_STYLE = 4; // Minimum artworks needed to use a style

        // Store artworks grouped by style
        let artworksByStyle = {};
        let availableStyles = [];
        let artworkImages = {}; // Cache loaded images

        // Audio context for sound effects
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playCollectSound() {
            if (!audioCtx) return;

            const now = audioCtx.currentTime;

            // Create a pleasant "collect" chime with multiple tones
            const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5 - major chord

            frequencies.forEach((freq, i) => {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(freq, now);

                // Stagger the notes slightly for an arpeggio effect
                const startTime = now + i * 0.05;
                const duration = 0.15;

                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.15, startTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

                oscillator.start(startTime);
                oscillator.stop(startTime + duration);
            });

            // Add a subtle high sparkle
            const sparkle = audioCtx.createOscillator();
            const sparkleGain = audioCtx.createGain();
            sparkle.connect(sparkleGain);
            sparkleGain.connect(audioCtx.destination);
            sparkle.type = 'sine';
            sparkle.frequency.setValueAtTime(1318.5, now); // E6
            sparkleGain.gain.setValueAtTime(0, now + 0.1);
            sparkleGain.gain.linearRampToValueAtTime(0.1, now + 0.12);
            sparkleGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            sparkle.start(now + 0.1);
            sparkle.stop(now + 0.3);
        }

        function playCaughtSound() {
            if (!audioCtx) return;

            const now = audioCtx.currentTime;

            // Descending "wah-wah" failure sound
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(400, now);
            oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.5);

            gainNode.gain.setValueAtTime(0.2, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

            oscillator.start(now);
            oscillator.stop(now + 0.5);

            // Add a second descending tone for depth
            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();

            osc2.connect(gain2);
            gain2.connect(audioCtx.destination);

            osc2.type = 'square';
            osc2.frequency.setValueAtTime(300, now + 0.1);
            osc2.frequency.exponentialRampToValueAtTime(80, now + 0.6);

            gain2.gain.setValueAtTime(0.1, now + 0.1);
            gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.6);

            osc2.start(now + 0.1);
            osc2.stop(now + 0.6);

            // Low thud
            const thud = audioCtx.createOscillator();
            const thudGain = audioCtx.createGain();

            thud.connect(thudGain);
            thudGain.connect(audioCtx.destination);

            thud.type = 'sine';
            thud.frequency.setValueAtTime(80, now);
            thud.frequency.exponentialRampToValueAtTime(40, now + 0.3);

            thudGain.gain.setValueAtTime(0.3, now);
            thudGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

            thud.start(now);
            thud.stop(now + 0.3);
        }

        // Music system
        let musicPlaying = false;
        let musicInterval = null;
        let currentBeat = 0;
        let musicGain = null;

        // Musical scales and patterns
        const bassNotes = [65.41, 73.42, 82.41, 87.31]; // C2, D2, E2, F2
        const melodyNotes = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00]; // C4-A4

        function startMusic() {
            if (!audioCtx || musicPlaying) return;
            musicPlaying = true;
            currentBeat = 0;

            // Master gain for music
            musicGain = audioCtx.createGain();
            musicGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            musicGain.connect(audioCtx.destination);

            playMusicLoop();
        }

        function stopMusic() {
            musicPlaying = false;
            if (musicInterval) {
                clearTimeout(musicInterval);
                musicInterval = null;
            }
        }

        function getTempoForLevel() {
            // Starts at 140 BPM, increases by 5 BPM per level, max 200 BPM
            const bpm = Math.min(140 + (gameState.level - 1) * 5, 200);
            return 60000 / bpm / 4; // Time per 16th note in ms
        }

        function playMusicLoop() {
            if (!musicPlaying || !audioCtx) return;

            const now = audioCtx.currentTime;
            const level = gameState.level;
            const beat = currentBeat % 16; // 16-step pattern

            // Kick drum on beats 0, 4, 8, 12
            if (beat % 4 === 0) {
                playKick(now);
            }

            // Hi-hat - more complex pattern at higher levels
            if (level >= 1 && beat % 2 === 0) {
                playHiHat(now, 0.05);
            }
            if (level >= 3 && beat % 2 === 1) {
                playHiHat(now, 0.02); // Quieter off-beats
            }
            if (level >= 5) {
                playHiHat(now, 0.015); // Even more hi-hats
            }

            // Bass line
            if (beat % 4 === 0) {
                const bassNote = bassNotes[Math.floor(beat / 4) % bassNotes.length];
                playBass(now, bassNote);
            }

            // Synth stabs at higher levels
            if (level >= 2 && (beat === 2 || beat === 10)) {
                playSynthStab(now);
            }

            // Melody at even higher levels
            if (level >= 4 && beat % 4 === 2) {
                const melodyNote = melodyNotes[Math.floor(Math.random() * melodyNotes.length)];
                playMelody(now, melodyNote);
            }

            // Tension notes at high levels
            if (level >= 6 && beat === 14) {
                playTension(now);
            }

            currentBeat++;
            musicInterval = setTimeout(playMusicLoop, getTempoForLevel());
        }

        function playKick(time) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(musicGain);

            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(30, time + 0.1);

            gain.gain.setValueAtTime(0.4, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);

            osc.start(time);
            osc.stop(time + 0.15);
        }

        function playHiHat(time, volume) {
            // Use noise-like sound for hi-hat
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            osc.type = 'square';
            osc.frequency.setValueAtTime(1000 + Math.random() * 500, time);

            filter.type = 'highpass';
            filter.frequency.setValueAtTime(7000, time);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(musicGain);

            gain.gain.setValueAtTime(volume, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);

            osc.start(time);
            osc.stop(time + 0.05);
        }

        function playBass(time, freq) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(freq, time);

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(200, time);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(musicGain);

            gain.gain.setValueAtTime(0.15, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);

            osc.start(time);
            osc.stop(time + 0.2);
        }

        function playSynthStab(time) {
            const frequencies = [130.81, 164.81, 196.00]; // C3, E3, G3 chord

            frequencies.forEach(freq => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, time);

                osc.connect(gain);
                gain.connect(musicGain);

                gain.gain.setValueAtTime(0.03, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);

                osc.start(time);
                osc.stop(time + 0.1);
            });
        }

        function playMelody(time, freq) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, time);

            osc.connect(gain);
            gain.connect(musicGain);

            gain.gain.setValueAtTime(0.08, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);

            osc.start(time);
            osc.stop(time + 0.15);
        }

        function playTension(time) {
            // Dissonant note for tension
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(233.08, time); // Bb3 - creates tension

            osc.connect(gain);
            gain.connect(musicGain);

            gain.gain.setValueAtTime(0.04, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);

            osc.start(time);
            osc.stop(time + 0.2);
        }

        // Screen effects
        let screenShake = { intensity: 0, duration: 0 };
        let screenFlash = { color: null, alpha: 0 };

        function triggerCaughtEffect(x, y) {
            // Screen shake
            screenShake.intensity = 10;
            screenShake.duration = 30;

            // Red flash
            screenFlash.color = '#e94560';
            screenFlash.alpha = 0.6;

            // Spawn dramatic particles
            const colors = ['#e94560', '#ff6b6b', '#ffffff', '#ffd700'];
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 6;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.015 + Math.random() * 0.01,
                    size: 4 + Math.random() * 6,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    type: Math.random() > 0.3 ? 'circle' : 'star'
                });
            }

            // Add multiple expanding rings
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: 0,
                    vy: 0,
                    life: 1.0,
                    decay: 0.025 + i * 0.01,
                    size: GUARD_SIZE / 2,
                    maxSize: GUARD_SIZE * 3,
                    color: i === 0 ? '#e94560' : '#ff6b6b',
                    type: 'ring'
                });
            }
        }

        function updateScreenEffects() {
            // Update screen shake
            if (screenShake.duration > 0) {
                screenShake.duration--;
                screenShake.intensity *= 0.9;
            }

            // Update screen flash
            if (screenFlash.alpha > 0) {
                screenFlash.alpha *= 0.9;
                if (screenFlash.alpha < 0.01) screenFlash.alpha = 0;
            }
        }

        function applyScreenShake() {
            if (screenShake.duration > 0) {
                const offsetX = (Math.random() - 0.5) * screenShake.intensity * 2;
                const offsetY = (Math.random() - 0.5) * screenShake.intensity * 2;
                ctx.translate(offsetX, offsetY);
            }
        }

        function drawScreenFlash() {
            if (screenFlash.alpha > 0) {
                ctx.fillStyle = screenFlash.color;
                ctx.globalAlpha = screenFlash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
            }
        }

        // Particle system for collection effects
        let particles = [];

        function spawnCollectParticles(x, y) {
            const colors = ['#ffd700', '#ffec8b', '#fff8dc', '#e94560', '#ffffff'];
            const particleCount = 20;

            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                const speed = 2 + Math.random() * 4;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 4,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    type: Math.random() > 0.5 ? 'circle' : 'star'
                });
            }

            // Add a ring effect
            particles.push({
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                life: 1.0,
                decay: 0.04,
                size: ARTWORK_SIZE / 2,
                maxSize: ARTWORK_SIZE * 1.5,
                color: '#ffd700',
                type: 'ring'
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= p.decay;

                if (p.type === 'ring') {
                    p.size += (p.maxSize - ARTWORK_SIZE / 2) * p.decay * 2;
                } else {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1; // gravity
                    p.vx *= 0.98; // friction
                }

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            for (const p of particles) {
                ctx.globalAlpha = p.life;

                if (p.type === 'ring') {
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 3 * p.life;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (p.type === 'star') {
                    drawStar(p.x, p.y, p.size, p.color);
                } else {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
        }

        function drawStar(x, y, size, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                const innerAngle = angle + Math.PI / 5;
                if (i === 0) {
                    ctx.moveTo(x + Math.cos(angle) * size, y + Math.sin(angle) * size);
                } else {
                    ctx.lineTo(x + Math.cos(angle) * size, y + Math.sin(angle) * size);
                }
                ctx.lineTo(x + Math.cos(innerAngle) * size * 0.4, y + Math.sin(innerAngle) * size * 0.4);
            }
            ctx.closePath();
            ctx.fill();
        }

        // Toast notification system
        const toastEl = document.getElementById('toast');
        let toastTimeout = null;

        function showToast(artworkData) {
            if (toastTimeout) clearTimeout(toastTimeout);

            const titleEl = toastEl.querySelector('.toast-title');
            const artistEl = toastEl.querySelector('.toast-artist');
            const detailsEl = toastEl.querySelector('.toast-details');

            titleEl.textContent = artworkData.title || 'Untitled';
            artistEl.textContent = artworkData.artist;

            const details = [];
            if (artworkData.date) details.push(artworkData.date);
            if (artworkData.origin) details.push(artworkData.origin);
            if (artworkData.medium) details.push(artworkData.medium);
            detailsEl.textContent = details.join(' ¬∑ ');
            if (artworkData.style) {
                detailsEl.textContent += (details.length ? ' ¬∑ ' : '') + artworkData.style;
            }

            toastEl.classList.add('show');

            toastTimeout = setTimeout(() => {
                toastEl.classList.remove('show');
            }, 3000);
        }

        // Fetch artworks from Art Institute of Chicago API
        async function fetchArtworks() {
            try {
                const randomPage = Math.floor(Math.random() * 10) + 1;
                const response = await fetch(
                    `https://api.artic.edu/api/v1/artworks/search?query[term][is_public_domain]=true&fields=id,title,image_id,artist_display,date_display,medium_display,place_of_origin,style_title&limit=100&page=${randomPage}`
                );
                const data = await response.json();

                // Group artworks by style
                artworksByStyle = {};
                for (const art of data.data) {
                    if (!art.image_id || !art.style_title) continue;

                    const style = art.style_title;
                    if (!artworksByStyle[style]) {
                        artworksByStyle[style] = [];
                    }

                    // Use direct URL for GitHub Pages, proxy for local dev
                    const isLocalDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                    const imageUrl = isLocalDev
                        ? `/iiif/2/${art.image_id}/full/80,/0/default.jpg`
                        : `https://www.artic.edu/iiif/2/${art.image_id}/full/80,/0/default.jpg`;

                    artworksByStyle[style].push({
                        id: art.id,
                        title: art.title,
                        artist: art.artist_display || 'Unknown artist',
                        date: art.date_display || 'Date unknown',
                        medium: art.medium_display || '',
                        origin: art.place_of_origin || '',
                        style: style,
                        imageUrl: imageUrl
                    });
                }

                // Filter to styles with enough artworks
                availableStyles = Object.keys(artworksByStyle)
                    .filter(style => artworksByStyle[style].length >= MIN_ARTWORKS_PER_STYLE);

                console.log(`Loaded ${availableStyles.length} art styles:`, availableStyles);
                gameState.artworksLoaded = true;
            } catch (error) {
                console.error('Failed to fetch artworks:', error);
                gameState.artworksLoaded = true;
            }
        }

        // Preload an artwork image
        function loadArtworkImage(artwork) {
            return new Promise((resolve) => {
                if (artworkImages[artwork.id]) {
                    resolve(artworkImages[artwork.id]);
                    return;
                }
                const img = new Image();
                // Only set crossOrigin for local dev (needed for canvas)
                // GitHub Pages: omit to avoid CORS preflight issues
                const isLocalDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                if (isLocalDev) {
                    img.crossOrigin = 'anonymous';
                }
                img.onload = () => {
                    artworkImages[artwork.id] = img;
                    resolve(img);
                };
                img.onerror = () => {
                    resolve(null);
                };
                img.src = artwork.imageUrl;
            });
        }

        function init() {
            gameState.playerX = 0;
            gameState.playerY = Math.random() * (canvas.height - 100) + 50;
            gameState.path = [{ x: gameState.playerX, y: gameState.playerY }];
            gameState.goingUp = false;
            gameState.gameOver = false;
            gameOverEl.classList.remove('show');
            hideFinishScreen();

            // Pick a new style for this level
            pickNewStyle();

            spawnGuards(4 + gameState.level);
            spawnArtworks(3 + gameState.level);
            spawnPowerups();
            updateActivePowerupsUI();
            updateUI();
        }

        function pickNewStyle() {
            // Get styles we haven't used yet
            const unusedStyles = availableStyles.filter(s => !gameState.usedStyles.includes(s));

            // If we've used all styles, reset
            if (unusedStyles.length === 0) {
                gameState.usedStyles = [];
                unusedStyles.push(...availableStyles);
            }

            if (unusedStyles.length > 0) {
                const randomIndex = Math.floor(Math.random() * unusedStyles.length);
                gameState.currentStyle = unusedStyles[randomIndex];
                gameState.usedStyles.push(gameState.currentStyle);
            } else {
                gameState.currentStyle = null;
            }
        }

        function spawnGuards(count) {
            gameState.guards = [];
            const margin = 50;
            const minX = 100; // Don't spawn guards too close to the start

            for (let i = 0; i < count; i++) {
                let guard;
                let attempts = 0;

                // Try to place guards without overlapping
                do {
                    guard = {
                        baseX: minX + Math.random() * (canvas.width - minX - margin),
                        baseY: margin + Math.random() * (canvas.height - margin * 2),
                        x: 0,
                        y: 0,
                        // Movement parameters
                        phase: Math.random() * Math.PI * 2,
                        speedX: 0.3 + Math.random() * 0.4,
                        speedY: 0.3 + Math.random() * 0.4,
                        radiusX: 15 + Math.random() * 20,
                        radiusY: 10 + Math.random() * 15
                    };
                    guard.x = guard.baseX;
                    guard.y = guard.baseY;
                    attempts++;
                } while (attempts < 50 && isOverlappingGuard(guard));

                gameState.guards.push(guard);
            }
        }

        function updateGuards() {
            const time = Date.now() / 1000;
            for (const guard of gameState.guards) {
                // Gentle oscillating movement
                guard.x = guard.baseX + Math.sin(time * guard.speedX + guard.phase) * guard.radiusX;
                guard.y = guard.baseY + Math.cos(time * guard.speedY + guard.phase) * guard.radiusY;

                // Keep guards within bounds
                guard.x = Math.max(GUARD_SIZE, Math.min(canvas.width - GUARD_SIZE, guard.x));
                guard.y = Math.max(GUARD_SIZE, Math.min(canvas.height - GUARD_SIZE, guard.y));
            }
        }

        function isOverlappingGuard(newGuard) {
            for (const guard of gameState.guards) {
                // Use baseX/baseY for spawn checking
                const gx = guard.baseX || guard.x;
                const gy = guard.baseY || guard.y;
                const nx = newGuard.baseX || newGuard.x;
                const ny = newGuard.baseY || newGuard.y;
                const dx = nx - gx;
                const dy = ny - gy;
                if (Math.sqrt(dx * dx + dy * dy) < GUARD_SIZE * 3) {
                    return true;
                }
            }
            return false;
        }

        function spawnArtworks(count) {
            gameState.artworks = [];
            const margin = 50;
            const minX = 80;

            // Get artworks for current style
            const styleArtworks = gameState.currentStyle
                ? artworksByStyle[gameState.currentStyle] || []
                : [];

            // Shuffle the style artworks to get random ones
            const shuffled = [...styleArtworks].sort(() => Math.random() - 0.5);

            for (let i = 0; i < count; i++) {
                let artwork;
                let attempts = 0;

                do {
                    artwork = {
                        x: minX + Math.random() * (canvas.width - minX - margin),
                        y: margin + Math.random() * (canvas.height - margin * 2),
                        collected: false
                    };
                    attempts++;
                } while (attempts < 50 && (isOverlappingGuard(artwork) || isOverlappingArtwork(artwork)));

                // Assign artwork from the current style (cycle through if needed)
                if (shuffled.length > 0) {
                    const artData = shuffled[i % shuffled.length];
                    artwork.data = artData;
                    loadArtworkImage(artData);
                }

                gameState.artworks.push(artwork);
            }
        }

        function isOverlappingArtwork(newArtwork) {
            for (const art of gameState.artworks) {
                const dx = newArtwork.x - art.x;
                const dy = newArtwork.y - art.y;
                if (Math.sqrt(dx * dx + dy * dy) < ARTWORK_SIZE * 1.5) {
                    return true;
                }
            }
            // Also check against guards (use base position + movement radius)
            for (const guard of gameState.guards) {
                const gx = guard.baseX || guard.x;
                const gy = guard.baseY || guard.y;
                const dx = newArtwork.x - gx;
                const dy = newArtwork.y - gy;
                const guardRadius = Math.max(guard.radiusX || 0, guard.radiusY || 0);
                if (Math.sqrt(dx * dx + dy * dy) < ARTWORK_SIZE + GUARD_SIZE + guardRadius) {
                    return true;
                }
            }
            return false;
        }

        function spawnPowerups() {
            gameState.powerups = [];
            const margin = 50;
            const minX = 150;
            const types = Object.keys(POWERUP_TYPES);

            // Spawn 1-2 random powerups per level
            const count = Math.min(1 + Math.floor(gameState.level / 3), 3);

            for (let i = 0; i < count; i++) {
                let powerup;
                let attempts = 0;

                do {
                    const baseX = minX + Math.random() * (canvas.width - minX - margin);
                    const baseY = margin + Math.random() * (canvas.height - margin * 2);
                    powerup = {
                        baseX: baseX,
                        baseY: baseY,
                        x: baseX,
                        y: baseY,
                        type: types[Math.floor(Math.random() * types.length)],
                        collected: false,
                        // Float animation properties
                        phase: Math.random() * Math.PI * 2,
                        floatSpeed: 1.5 + Math.random() * 1,
                        floatRadius: 5 + Math.random() * 5
                    };
                    attempts++;
                } while (attempts < 50 && isOverlappingPowerup(powerup));

                gameState.powerups.push(powerup);
            }
        }

        function isOverlappingPowerup(newPowerup) {
            // Check against other powerups (use base positions)
            for (const p of gameState.powerups) {
                const dx = newPowerup.baseX - (p.baseX || p.x);
                const dy = newPowerup.baseY - (p.baseY || p.y);
                if (Math.sqrt(dx * dx + dy * dy) < POWERUP_SIZE * 3) {
                    return true;
                }
            }
            // Check against artworks
            for (const art of gameState.artworks) {
                const dx = newPowerup.x - art.x;
                const dy = newPowerup.y - art.y;
                if (Math.sqrt(dx * dx + dy * dy) < POWERUP_SIZE + ARTWORK_SIZE) {
                    return true;
                }
            }
            // Check against guards
            for (const guard of gameState.guards) {
                const gx = guard.baseX || guard.x;
                const gy = guard.baseY || guard.y;
                const dx = newPowerup.x - gx;
                const dy = newPowerup.y - gy;
                if (Math.sqrt(dx * dx + dy * dy) < POWERUP_SIZE + GUARD_SIZE + 30) {
                    return true;
                }
            }
            return false;
        }

        function collectPowerup(powerup) {
            powerup.collected = true;
            spawnCollectParticles(powerup.x, powerup.y);
            playPowerupSound();

            switch (powerup.type) {
                case 'magnet':
                    gameState.activePowerups.magnet.active = true;
                    gameState.activePowerups.magnet.duration = POWERUP_TYPES.magnet.duration;
                    break;

                case 'bulkHeist':
                    // Trigger visual effect
                    triggerBulkHeistEffect(gameState.playerX, gameState.playerY);
                    // Collect all artworks within radius
                    const radius = POWERUP_TYPES.bulkHeist.radius;
                    for (const art of gameState.artworks) {
                        if (art.collected) continue;
                        const dx = gameState.playerX - art.x;
                        const dy = gameState.playerY - art.y;
                        if (Math.sqrt(dx * dx + dy * dy) < radius) {
                            art.collected = true;
                            gameState.score += 50;
                            spawnCollectParticles(art.x, art.y);
                            if (art.data) {
                                gameState.stolenArtworks.push(art.data);
                            }
                        }
                    }
                    updateUI();
                    break;

                case 'shield':
                    gameState.activePowerups.shield.active = true;
                    gameState.activePowerups.shield.count = 1;
                    break;

                case 'bribe':
                    // Find nearest guard and convert to artwork
                    let nearestGuard = null;
                    let nearestDist = Infinity;
                    for (let i = 0; i < gameState.guards.length; i++) {
                        const guard = gameState.guards[i];
                        const dx = gameState.playerX - guard.x;
                        const dy = gameState.playerY - guard.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestGuard = i;
                        }
                    }
                    if (nearestGuard !== null) {
                        const guard = gameState.guards[nearestGuard];
                        // Create artwork at guard position
                        const styleArtworks = gameState.currentStyle
                            ? artworksByStyle[gameState.currentStyle] || []
                            : [];
                        const newArt = {
                            x: guard.x,
                            y: guard.y,
                            collected: false,
                            data: styleArtworks.length > 0
                                ? styleArtworks[Math.floor(Math.random() * styleArtworks.length)]
                                : null
                        };
                        if (newArt.data) loadArtworkImage(newArt.data);
                        gameState.artworks.push(newArt);
                        // Remove guard with effect
                        spawnBribeParticles(guard.x, guard.y);
                        gameState.guards.splice(nearestGuard, 1);
                    }
                    break;
            }

            updateActivePowerupsUI();
        }

        function spawnBribeParticles(x, y) {
            const colors = ['#ffd700', '#50fa7b', '#fff'];
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.02,
                    size: 4 + Math.random() * 4,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    type: 'circle'
                });
            }
        }

        function playPowerupSound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;

            // Ascending powerup sound
            const frequencies = [392.00, 523.25, 659.25, 783.99]; // G4, C5, E5, G5

            frequencies.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, now + i * 0.06);
                gain.gain.setValueAtTime(0, now + i * 0.06);
                gain.gain.linearRampToValueAtTime(0.12, now + i * 0.06 + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.06 + 0.15);
                osc.start(now + i * 0.06);
                osc.stop(now + i * 0.06 + 0.15);
            });
        }

        function updatePowerups() {
            // Update magnet duration
            if (gameState.activePowerups.magnet.active) {
                gameState.activePowerups.magnet.duration--;
                if (gameState.activePowerups.magnet.duration <= 0) {
                    gameState.activePowerups.magnet.active = false;
                }
                updateActivePowerupsUI();

                // Pull artworks toward player
                for (const art of gameState.artworks) {
                    if (art.collected) continue;
                    const dx = gameState.playerX - art.x;
                    const dy = gameState.playerY - art.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200 && dist > 10) {
                        art.x += (dx / dist) * 2;
                        art.y += (dy / dist) * 2;
                    }
                }
            }
        }

        function updateActivePowerupsUI() {
            const container = document.getElementById('active-powerups');
            container.innerHTML = '';

            if (gameState.activePowerups.magnet.active) {
                const el = document.createElement('div');
                el.className = 'active-powerup';
                const seconds = Math.ceil(gameState.activePowerups.magnet.duration / 60);
                el.innerHTML = `üß≤ <span class="powerup-timer">${seconds}s</span>`;
                container.appendChild(el);
            }

            if (gameState.activePowerups.shield.active) {
                const el = document.createElement('div');
                el.className = 'active-powerup';
                el.innerHTML = `üõ°Ô∏è`;
                container.appendChild(el);
            }
        }

        function drawPowerups() {
            ctx.font = `${POWERUP_SIZE}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const time = Date.now() / 1000;

            for (const powerup of gameState.powerups) {
                if (powerup.collected) continue;

                // Calculate floating position
                const floatX = Math.sin(time * powerup.floatSpeed + powerup.phase) * powerup.floatRadius;
                const floatY = Math.cos(time * powerup.floatSpeed * 0.7 + powerup.phase) * powerup.floatRadius;
                powerup.x = powerup.baseX + floatX;
                powerup.y = powerup.baseY + floatY;

                const type = POWERUP_TYPES[powerup.type];

                // Draw glow effect
                ctx.save();
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 15;

                // Draw background circle
                ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, POWERUP_SIZE * 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Draw icon
                ctx.fillText(type.icon, powerup.x, powerup.y);
                ctx.restore();
            }
        }

        // Bulk heist collection effect
        let bulkHeistEffect = null;

        function triggerBulkHeistEffect(x, y) {
            bulkHeistEffect = {
                x: x,
                y: y,
                radius: POWERUP_TYPES.bulkHeist.radius,
                progress: 0
            };
        }

        function updateBulkHeistEffect() {
            if (!bulkHeistEffect) return;

            bulkHeistEffect.progress += 0.03;

            if (bulkHeistEffect.progress >= 1) {
                bulkHeistEffect = null;
            }
        }

        function drawBulkHeistEffect() {
            if (!bulkHeistEffect) return;

            const { x, y, radius, progress } = bulkHeistEffect;

            // Contracting circle animation
            const currentRadius = radius * (1 - progress);
            const alpha = 1 - progress;

            // Outer ring contracting inward
            ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner glow
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, currentRadius);
            gradient.addColorStop(0, `rgba(255, 215, 0, ${alpha * 0.3})`);
            gradient.addColorStop(0.7, `rgba(255, 215, 0, ${alpha * 0.1})`);
            gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
            ctx.fill();

            // Sparkle ring at the edge
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, currentRadius * 0.95, 0, Math.PI * 2);
            ctx.stroke();
        }

        function updateUI() {
            levelEl.textContent = gameState.level;
            scoreEl.textContent = gameState.score;
            themeEl.textContent = gameState.currentStyle || 'Mixed';
        }

        async function showFinishScreen() {
            document.getElementById('finish-level').textContent = gameState.level;
            document.getElementById('finish-count').textContent = gameState.stolenArtworks.length;
            document.getElementById('finish-score').textContent = gameState.score;

            const lootGrid = document.getElementById('loot-grid');
            lootGrid.innerHTML = '';

            if (gameState.stolenArtworks.length === 0) {
                lootGrid.innerHTML = '<div class="no-loot">No artworks stolen... maybe next time!</div>';
            } else {
                for (const art of gameState.stolenArtworks) {
                    const item = document.createElement('a');
                    item.className = 'loot-item';
                    item.href = `https://www.artic.edu/artworks/${art.id}`;
                    item.target = '_blank';
                    item.rel = 'noopener noreferrer';

                    const img = artworkImages[art.id];
                    let imageHtml;
                    if (img) {
                        imageHtml = `<img class="loot-image" src="${art.imageUrl}" alt="${art.title}">`;
                    } else {
                        imageHtml = `<div class="loot-image-placeholder">ART</div>`;
                    }

                    const details = [];
                    if (art.date) details.push(art.date);
                    if (art.origin) details.push(art.origin);
                    if (art.medium) details.push(art.medium);

                    item.innerHTML = `
                        ${imageHtml}
                        <div class="loot-info">
                            <div class="loot-title">${art.title || 'Untitled'}</div>
                            <div class="loot-artist">${art.artist}</div>
                            <div class="loot-details">${details.join(' ¬∑ ')}</div>
                            <div class="loot-style">${art.style || ''}</div>
                        </div>
                    `;

                    lootGrid.appendChild(item);
                }
            }

            finishScreenEl.classList.add('show');

            // Fetch and display leaderboard (after finish screen is visible)
            playerSubmittedScore = false;
            await fetchLeaderboard();

            // Check if player qualifies for top 25 and has a score
            if (gameState.score > 0 && checkIfQualifiesForTop25(gameState.score)) {
                showNameEntryModal(gameState.score);
            } else {
                displayLeaderboard(gameState.score);
            }
        }

        function hideFinishScreen() {
            finishScreenEl.classList.remove('show');
        }

        function update() {
            // Always update effects even when game over
            updateParticles();
            updateScreenEffects();
            updateBulkHeistEffect();

            if (gameState.gameOver) return;
            if (!gameState.gameStarted) return;

            // Update guard positions
            updateGuards();

            // Update powerups
            updatePowerups();

            // Move player
            const angle = gameState.goingUp ? -Math.PI / 4 : Math.PI / 4;
            gameState.playerX += Math.cos(angle) * gameState.speed;
            gameState.playerY += Math.sin(angle) * gameState.speed;

            // Wrap around top/bottom
            if (gameState.playerY < 0) {
                // Add current path segment end point
                gameState.path.push({ x: gameState.playerX, y: 0 });
                // Start new segment from bottom
                gameState.playerY = canvas.height;
                gameState.path.push({ x: gameState.playerX, y: canvas.height, newSegment: true });
            } else if (gameState.playerY > canvas.height) {
                // Add current path segment end point
                gameState.path.push({ x: gameState.playerX, y: canvas.height });
                // Start new segment from top
                gameState.playerY = 0;
                gameState.path.push({ x: gameState.playerX, y: 0, newSegment: true });
            }

            // Add to path
            gameState.path.push({ x: gameState.playerX, y: gameState.playerY });

            // Check collision with powerups
            for (const powerup of gameState.powerups) {
                if (powerup.collected) continue;
                const dx = gameState.playerX - powerup.x;
                const dy = gameState.playerY - powerup.y;
                if (Math.sqrt(dx * dx + dy * dy) < POWERUP_SIZE / 2 + 5) {
                    collectPowerup(powerup);
                }
            }

            // Check collision with artworks (collect them)
            for (const artwork of gameState.artworks) {
                if (artwork.collected) continue;
                const dx = gameState.playerX - artwork.x;
                const dy = gameState.playerY - artwork.y;
                if (Math.sqrt(dx * dx + dy * dy) < ARTWORK_SIZE / 2 + 5) {
                    artwork.collected = true;
                    gameState.score += 50;
                    updateUI();
                    spawnCollectParticles(artwork.x, artwork.y);
                    playCollectSound();
                    if (artwork.data) {
                        gameState.stolenArtworks.push(artwork.data);
                        showToast(artwork.data);
                    }
                }
            }

            // Check collision with guards
            for (let i = gameState.guards.length - 1; i >= 0; i--) {
                const guard = gameState.guards[i];
                const dx = gameState.playerX - guard.x;
                const dy = gameState.playerY - guard.y;
                if (Math.sqrt(dx * dx + dy * dy) < GUARD_SIZE / 2 + 5) {
                    // Check for shield
                    if (gameState.activePowerups.shield.active) {
                        gameState.activePowerups.shield.active = false;
                        gameState.activePowerups.shield.count = 0;
                        // Remove the guard we collided with
                        spawnBribeParticles(guard.x, guard.y);
                        gameState.guards.splice(i, 1);
                        playPowerupSound();
                        updateActivePowerupsUI();
                        continue;
                    }

                    gameState.gameOver = true;
                    stopMusic();
                    triggerCaughtEffect(gameState.playerX, gameState.playerY);
                    playCaughtSound();
                    // Delay showing finish screen to let effect play
                    setTimeout(showFinishScreen, 800);
                    return;
                }
            }

            // Check if reached right side
            if (gameState.playerX >= canvas.width) {
                gameState.level++;
                gameState.score += 100;
                init();
            }
        }

        function draw() {
            // Save context state and apply screen shake
            ctx.save();
            applyScreenShake();

            // Clear canvas
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid lines for visual effect
            ctx.strokeStyle = '#1a1a3e';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw artworks
            for (const artwork of gameState.artworks) {
                if (artwork.collected) continue;

                const img = artwork.data ? artworkImages[artwork.data.id] : null;
                if (img) {
                    // Draw the artwork image with a gold frame
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(
                        artwork.x - ARTWORK_SIZE / 2 - 2,
                        artwork.y - ARTWORK_SIZE / 2 - 2,
                        ARTWORK_SIZE + 4,
                        ARTWORK_SIZE + 4
                    );
                    ctx.drawImage(
                        img,
                        artwork.x - ARTWORK_SIZE / 2,
                        artwork.y - ARTWORK_SIZE / 2,
                        ARTWORK_SIZE,
                        ARTWORK_SIZE
                    );
                } else {
                    // Fallback: draw a colorful placeholder
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(
                        artwork.x - ARTWORK_SIZE / 2,
                        artwork.y - ARTWORK_SIZE / 2,
                        ARTWORK_SIZE,
                        ARTWORK_SIZE
                    );
                    ctx.fillStyle = '#16213e';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ART', artwork.x, artwork.y);
                }
            }

            // Draw powerups
            drawPowerups();

            // Draw bulk heist effect
            drawBulkHeistEffect();

            // Draw guards
            const ALERT_DISTANCE = 120;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (const guard of gameState.guards) {
                // Check distance to player
                const dx = gameState.playerX - guard.x;
                const dy = gameState.playerY - guard.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const isAlert = distance < ALERT_DISTANCE && gameState.gameStarted;
                const alertLevel = isAlert ? 1 - (distance / ALERT_DISTANCE) : 0;

                ctx.save();

                // Fade guards when shield is active
                if (gameState.activePowerups.shield.active) {
                    ctx.globalAlpha = 0.4;
                }

                // Alert glow effect
                if (isAlert && !gameState.activePowerups.shield.active) {
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 15 * alertLevel;
                }

                // Draw guard (slightly larger when alert)
                const size = GUARD_SIZE * (1 + alertLevel * 0.2);
                ctx.font = `${size}px Arial`;
                ctx.fillText(GUARD_EMOJI, guard.x, guard.y);

                // Draw alert indicator
                if (isAlert && !gameState.activePowerups.shield.active) {
                    ctx.font = '16px Arial';
                    ctx.fillStyle = `rgba(255, 50, 50, ${alertLevel})`;
                    ctx.fillText('!', guard.x + GUARD_SIZE * 0.4, guard.y - GUARD_SIZE * 0.5);
                }

                ctx.restore();
            }

            // Draw path
            if (gameState.path.length > 1) {
                ctx.strokeStyle = '#e94560';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(gameState.path[0].x, gameState.path[0].y);

                for (let i = 1; i < gameState.path.length; i++) {
                    if (gameState.path[i].newSegment) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(gameState.path[i].x, gameState.path[i].y);
                    } else {
                        ctx.lineTo(gameState.path[i].x, gameState.path[i].y);
                    }
                }
                ctx.stroke();
            }

            // Draw player position (small circle at the head of the line)
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(gameState.playerX, gameState.playerY, 6, 0, Math.PI * 2);
            ctx.fill();

            // Draw direction indicator
            const angle = gameState.goingUp ? -Math.PI / 4 : Math.PI / 4;
            const indicatorLength = 15;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(gameState.playerX, gameState.playerY);
            ctx.lineTo(
                gameState.playerX + Math.cos(angle) * indicatorLength,
                gameState.playerY + Math.sin(angle) * indicatorLength
            );
            ctx.stroke();

            // Draw screen flash
            drawScreenFlash();

            // Draw particles on top of everything
            drawParticles();

            // Restore context state
            ctx.restore();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Splash screen
        const splashScreen = document.getElementById('splash-screen');

        function hideSplashScreen() {
            splashScreen.classList.add('hidden');
            gameState.gameStarted = true;
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            // Initialize audio on first interaction (browser requirement)
            initAudio();

            // Handle splash screen
            if (!splashScreen.classList.contains('hidden')) {
                if (e.code === 'Space') {
                    e.preventDefault();
                    hideSplashScreen();
                    startMusic();
                }
                return;
            }

            if (!musicPlaying && !gameState.gameOver) {
                startMusic();
            }

            if (e.code === 'Space') {
                e.preventDefault();
                gameState.goingUp = true;
            }
            if (e.code === 'KeyR') {
                const nameModal = document.getElementById('name-entry-modal');
                if (!nameModal.classList.contains('show')) {
                    restartGame();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && gameState.gameStarted) {
                gameState.goingUp = false;
            }
        });

        // Prevent space from scrolling
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
            }
        });

        // Touch/click controls for mobile
        function handlePointerDown(e) {
            e.preventDefault();
            initAudio();

            // Handle splash screen
            if (!splashScreen.classList.contains('hidden')) {
                hideSplashScreen();
                startMusic();
                return;
            }

            if (!musicPlaying && !gameState.gameOver) {
                startMusic();
            }

            gameState.goingUp = true;
        }

        function handlePointerUp(e) {
            if (gameState.gameStarted) {
                gameState.goingUp = false;
            }
        }

        // Mouse controls
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('mouseleave', handlePointerUp);

        // Touch controls
        canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
        canvas.addEventListener('touchend', handlePointerUp);
        canvas.addEventListener('touchcancel', handlePointerUp);

        // Prevent default touch behavior on canvas
        canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

        // Splash screen click/touch to start
        splashScreen.addEventListener('click', handlePointerDown);
        splashScreen.addEventListener('touchstart', handlePointerDown, { passive: false });

        // Triple-tap to restart on finish screen
        let tapCount = 0;
        let tapTimer = null;

        function handleTripleTap() {
            tapCount++;

            if (tapTimer) clearTimeout(tapTimer);

            if (tapCount >= 3) {
                tapCount = 0;
                restartGame();
            } else {
                tapTimer = setTimeout(() => {
                    tapCount = 0;
                }, 500);
            }
        }

        function restartGame() {
            gameState.level = 1;
            gameState.score = 0;
            gameState.usedStyles = [];
            gameState.stolenArtworks = [];
            gameState.activePowerups.magnet = { active: false, duration: 0 };
            gameState.activePowerups.shield = { active: false, count: 0 };
            particles = [];
            screenShake = { intensity: 0, duration: 0 };
            screenFlash = { color: null, alpha: 0 };
            bulkHeistEffect = null;
            hideFinishScreen();
            stopMusic();
            init();
            startMusic();
        }

        finishScreenEl.addEventListener('click', (e) => {
            // Don't trigger if clicking on an artwork link
            if (e.target.closest('.loot-item')) return;
            handleTripleTap();
        });
        finishScreenEl.addEventListener('touchend', (e) => {
            if (e.target.closest('.loot-item')) return;
            handleTripleTap();
        });

        // Start game - fetch artworks first, then initialize
        async function startGame() {
            // Show loading message
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '24px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Loading artworks...', canvas.width / 2, canvas.height / 2);

            await fetchArtworks();
            init();
            gameLoop();
        }

        initConfigPanel();
        startGame();
    </script>
</body>

</html>