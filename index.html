<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Art Heist - A browser game where you steal famous artworks while avoiding security guards">
    <title>Art Heist</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0d0d1a;
            font-family: 'Courier New', monospace;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            position: relative;
        }
        #game-canvas {
            border: 3px solid #e94560;
            background: #16213e;
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.3), inset 0 0 60px rgba(0, 0, 0, 0.5);
        }
        #game-canvas:focus {
            outline: 3px solid #ffd700;
            outline-offset: 2px;
        }
        #ui {
            color: #ffffff;
            font-size: 18px;
            display: flex;
            gap: 30px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        #ui .label {
            color: #b0b0b0;
            font-weight: normal;
        }
        #ui .value {
            color: #ffd700;
        }
        #combo-display {
            position: absolute;
            top: 50px;
            right: 20px;
            color: #ff6b6b;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.8);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            transform: scale(1);
        }
        #combo-display.active {
            opacity: 1;
            animation: comboPulse 0.5s ease-in-out infinite;
        }
        @keyframes comboPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        #high-score {
            color: #b0b0b0;
            font-size: 14px;
        }
        #high-score .value {
            color: #ffd700;
        }
        #instructions {
            color: #d0d0d0;
            font-size: 14px;
            margin-top: 10px;
            text-align: center;
            line-height: 1.6;
            max-width: 600px;
        }
        #instructions kbd {
            background: #2a2a4a;
            border: 1px solid #4a4a6a;
            border-radius: 4px;
            padding: 2px 6px;
            font-family: inherit;
            color: #ffffff;
        }
        #game-over {
            display: none;
            position: absolute;
            color: #e94560;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 20px rgba(233, 69, 96, 0.5);
        }
        #game-over.show {
            display: block;
        }
        #toast {
            position: absolute;
            bottom: 20px;
            right: 20px;
            left: auto;
            transform: none;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            border-radius: 6px;
            padding: 8px 12px;
            max-width: 220px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            font-size: 11px;
        }
        #toast.show {
            opacity: 1;
        }
        #toast .toast-title {
            color: #ffd700;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #toast .toast-artist {
            color: #ffffff;
            font-size: 10px;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #toast .toast-details {
            display: none;
        }
        #toast .toast-stolen {
            display: none;
        }
        #toast .toast-points {
            color: #4ade80;
            font-size: 12px;
            font-weight: bold;
            margin-top: 2px;
        }
        #title-screen {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0d0d1a;
            z-index: 200;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 30px;
        }
        #title-screen.hidden {
            display: none;
        }
        #title-screen .title {
            font-size: 72px;
            font-weight: bold;
            color: #e94560;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.8), 0 0 60px rgba(233, 69, 96, 0.4);
            animation: titleGlow 2s ease-in-out infinite;
        }
        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 30px rgba(233, 69, 96, 0.8), 0 0 60px rgba(233, 69, 96, 0.4); }
            50% { text-shadow: 0 0 40px rgba(233, 69, 96, 1), 0 0 80px rgba(233, 69, 96, 0.6); }
        }
        #title-screen .subtitle {
            font-size: 24px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        #title-screen .start-prompt {
            font-size: 20px;
            color: #ffffff;
            animation: blink 1.5s ease-in-out infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        #title-screen .thief-silhouette {
            font-size: 120px;
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        #finish-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 13, 26, 0.98);
            z-index: 100;
            overflow-x: hidden;
            overflow-y: auto;
            padding: 40px 20px;
        }
        #finish-screen.show {
            display: block;
        }
        #finish-screen .finish-header {
            text-align: center;
            margin-bottom: 30px;
        }
        #finish-screen .finish-title {
            color: #e94560;
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }
        #finish-screen .finish-stats {
            color: #d0d0d0;
            font-size: 18px;
            line-height: 1.8;
        }
        #finish-screen .finish-stats span {
            color: #ffd700;
            font-weight: bold;
        }
        #finish-screen .new-high-score {
            color: #4ade80;
            font-size: 24px;
            font-weight: bold;
            margin-top: 15px;
            animation: highScorePulse 0.5s ease-in-out infinite;
        }
        @keyframes highScorePulse {
            0%, 100% { text-shadow: 0 0 10px rgba(74, 222, 128, 0.8); }
            50% { text-shadow: 0 0 20px rgba(74, 222, 128, 1), 0 0 30px rgba(74, 222, 128, 0.6); }
        }
        #finish-screen .loot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto 30px;
        }
        #finish-screen .loot-item {
            background: #16213e;
            border: 2px solid #ffd700;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #finish-screen .loot-item:hover,
        #finish-screen .loot-item:focus-within {
            transform: translateY(-3px);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.4);
        }
        #finish-screen .loot-image {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border: 2px solid #ffd700;
            flex-shrink: 0;
        }
        #finish-screen .loot-image-placeholder {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #ffd700, #ff9500);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #16213e;
            font-weight: bold;
            flex-shrink: 0;
        }
        #finish-screen .loot-info {
            flex: 1;
            min-width: 0;
        }
        #finish-screen .loot-link {
            text-decoration: none;
            color: inherit;
            display: flex;
            gap: 15px;
            padding: 15px;
        }
        #finish-screen .loot-link:hover .loot-title,
        #finish-screen .loot-link:focus .loot-title {
            text-decoration: underline;
        }
        #finish-screen .loot-link:focus {
            outline: 2px solid #ffd700;
            outline-offset: -2px;
            border-radius: 6px;
        }
        #finish-screen .loot-title {
            color: #ffd700;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 6px;
            line-height: 1.3;
        }
        #finish-screen .loot-artist {
            color: #ffffff;
            font-size: 13px;
            margin-bottom: 4px;
        }
        #finish-screen .loot-details {
            color: #d0d0d0;
            font-size: 12px;
            line-height: 1.4;
        }
        #finish-screen .loot-style {
            color: #ff8a8a;
            font-size: 11px;
            margin-top: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: bold;
        }
        #finish-screen .finish-footer {
            text-align: center;
            color: #d0d0d0;
            font-size: 16px;
        }
        #finish-screen .finish-footer kbd {
            background: #2a2a4a;
            border: 1px solid #4a4a6a;
            border-radius: 4px;
            padding: 2px 8px;
            color: #ffffff;
        }
        #finish-screen .no-loot {
            text-align: center;
            color: #d0d0d0;
            font-size: 18px;
            padding: 40px;
        }
        #finish-screen .loot-title,
        #finish-screen .loot-artist,
        #finish-screen .loot-details,
        #finish-screen .loot-style {
            margin: 0;
        }
        /* Screen reader only */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        /* Reduced motion preference */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <!-- Screen reader announcements -->
    <div id="sr-announcements" class="sr-only" aria-live="polite" aria-atomic="true"></div>

    <!-- Title Screen -->
    <div id="title-screen" role="dialog" aria-labelledby="game-title">
        <div class="thief-silhouette" aria-hidden="true">üïµÔ∏è</div>
        <h1 class="title" id="game-title">ART HEIST</h1>
        <p class="subtitle">Steal the world's greatest masterpieces</p>
        <p class="start-prompt">Press <kbd>SPACE</kbd> to begin</p>
    </div>

    <main id="game-container">
        <header id="ui" role="status" aria-live="polite">
            <span><span class="label">Level:</span> <span class="value" id="level">1</span></span>
            <span><span class="label">Score:</span> <span class="value" id="score">0</span></span>
            <span><span class="label">Theme:</span> <span class="value" id="theme">-</span></span>
        </header>
        <div id="high-score"><span class="label">Best:</span> <span class="value" id="best-score">0</span></div>
        <canvas id="game-canvas" width="800" height="500" tabindex="0" role="img" aria-label="Art Heist game area. Use spacebar to control direction."></canvas>
        <div id="combo-display" aria-live="polite">COMBO x<span id="combo-count">2</span></div>
        <div id="game-over" role="alert">CAUGHT! Press R to restart</div>
        <div id="toast" role="status" aria-live="polite">
            <div class="toast-title"></div>
            <div class="toast-artist"></div>
            <div class="toast-details"></div>
            <div class="toast-points"></div>
            <div class="toast-stolen">STOLEN!</div>
        </div>
        <nav id="instructions">
            Hold <kbd>SPACE</kbd> to go up, release to go down<br>
            Collect art for points, avoid guards<br>
            Press <kbd>R</kbd> to restart
        </nav>
    </main>

    <div id="finish-screen" role="dialog" aria-labelledby="finish-title">
        <div class="finish-header">
            <h2 class="finish-title" id="finish-title">CAUGHT!</h2>
            <div class="finish-stats">
                You reached level <span id="finish-level">1</span><br>
                Stole <span id="finish-count">0</span> artworks<br>
                Final score: <span id="finish-score">0</span> points
            </div>
            <div class="new-high-score" id="new-high-score" style="display: none;">NEW HIGH SCORE!</div>
        </div>
        <div class="loot-grid" id="loot-grid" role="list" aria-label="Stolen artworks"></div>
        <div class="finish-footer">Press <kbd>R</kbd> to try again</div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameOverEl = document.getElementById('game-over');
        const levelEl = document.getElementById('level');
        const scoreEl = document.getElementById('score');
        const themeEl = document.getElementById('theme');
        const titleScreenEl = document.getElementById('title-screen');
        const comboDisplayEl = document.getElementById('combo-display');
        const comboCountEl = document.getElementById('combo-count');
        const srAnnouncementsEl = document.getElementById('sr-announcements');
        const bestScoreEl = document.getElementById('best-score');

        // Announce to screen readers
        function announce(message) {
            srAnnouncementsEl.textContent = message;
        }

        // High score persistence
        let highScore = parseInt(localStorage.getItem('artHeistHighScore')) || 0;
        bestScoreEl.textContent = highScore;

        function updateHighScore(score) {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('artHeistHighScore', highScore);
                bestScoreEl.textContent = highScore;
                return true;
            }
            return false;
        }

        // Game state
        let gameState = {
            playerX: 0,
            playerY: 0,
            path: [],
            guards: [],
            artworks: [],
            powerUps: [],
            lasers: [],
            goingUp: false,
            gameOver: false,
            gameStarted: false,
            level: 1,
            score: 0,
            speed: 4,
            baseSpeed: 4,
            artworksLoaded: false,
            currentStyle: null,
            usedStyles: [],
            stolenArtworks: [],
            // Combo system
            combo: 0,
            comboTimer: 0,
            lastCollectTime: 0,
            // Time effects
            timeScale: 1,
            slowMoTimer: 0,
            // Power-ups
            isInvisible: false,
            invisibleTimer: 0,
            hasMagnet: false,
            magnetTimer: 0,
            // Near miss tracking
            nearMissTimer: 0,
            // Level transition
            levelTransition: false,
            levelTransitionTimer: 0,
            // Danger level for heartbeat
            dangerLevel: 0
        };

        const finishScreenEl = document.getElementById('finish-screen');

        const GUARD_SIZE = 30;
        const ARTWORK_SIZE = 50;
        const MIN_ARTWORKS_PER_STYLE = 4;
        const COMBO_WINDOW = 2000; // ms to maintain combo
        const POWER_UP_SIZE = 25;

        // Store artworks grouped by style
        let artworksByStyle = {};
        let availableStyles = [];
        let artworkImages = {};

        // Floating text system
        let floatingTexts = [];

        function spawnFloatingText(x, y, text, color = '#ffd700') {
            floatingTexts.push({
                x, y,
                text,
                color,
                life: 1.0,
                vy: -2
            });
        }

        // Audio context for sound effects
        let audioCtx = null;
        let musicPlaying = false;
        let heartbeatInterval = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Background music using Web Audio API
        function startBackgroundMusic() {
            if (!audioCtx || musicPlaying) return;
            musicPlaying = true;

            function playNote(freq, startTime, duration, type = 'sine', volume = 0.05) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = type;
                osc.frequency.setValueAtTime(freq, startTime);
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(volume, startTime + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                osc.start(startTime);
                osc.stop(startTime + duration);
            }

            // Ambient heist music loop
            function playMusicLoop() {
                if (!musicPlaying || !audioCtx) return;
                const now = audioCtx.currentTime;
                const bpm = 100;
                const beatDuration = 60 / bpm;

                // Bass line (mysterious)
                const bassNotes = [65.41, 73.42, 82.41, 73.42]; // C2, D2, E2, D2
                bassNotes.forEach((note, i) => {
                    playNote(note, now + i * beatDuration, beatDuration * 0.8, 'triangle', 0.08);
                });

                // High tension notes
                const highNotes = [261.63, 293.66, 329.63, 293.66]; // C4, D4, E4, D4
                highNotes.forEach((note, i) => {
                    if (i % 2 === 0) {
                        playNote(note, now + i * beatDuration + beatDuration / 2, beatDuration * 0.3, 'sine', 0.03);
                    }
                });

                setTimeout(playMusicLoop, beatDuration * 4 * 1000);
            }

            playMusicLoop();
        }

        function playHeartbeat(intensity) {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const volume = 0.1 + intensity * 0.2;

            // First beat (lub)
            const lub = audioCtx.createOscillator();
            const lubGain = audioCtx.createGain();
            lub.connect(lubGain);
            lubGain.connect(audioCtx.destination);
            lub.type = 'sine';
            lub.frequency.setValueAtTime(60, now);
            lub.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            lubGain.gain.setValueAtTime(volume, now);
            lubGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            lub.start(now);
            lub.stop(now + 0.15);

            // Second beat (dub)
            const dub = audioCtx.createOscillator();
            const dubGain = audioCtx.createGain();
            dub.connect(dubGain);
            dubGain.connect(audioCtx.destination);
            dub.type = 'sine';
            dub.frequency.setValueAtTime(50, now + 0.2);
            dub.frequency.exponentialRampToValueAtTime(35, now + 0.3);
            dubGain.gain.setValueAtTime(volume * 0.7, now + 0.2);
            dubGain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
            dub.start(now + 0.2);
            dub.stop(now + 0.35);
        }

        function updateHeartbeat() {
            if (gameState.dangerLevel > 0.3 && !gameState.gameOver) {
                const interval = Math.max(300, 800 - gameState.dangerLevel * 500);
                if (!heartbeatInterval || Date.now() - (heartbeatInterval.lastBeat || 0) > interval) {
                    playHeartbeat(gameState.dangerLevel);
                    if (!heartbeatInterval) heartbeatInterval = {};
                    heartbeatInterval.lastBeat = Date.now();
                }
            }
        }

        function playCollectSound(comboMultiplier = 1) {
            if (!audioCtx) return;

            const now = audioCtx.currentTime;
            // Pitch increases with combo
            const pitchMultiplier = 1 + (comboMultiplier - 1) * 0.1;
            const frequencies = [523.25 * pitchMultiplier, 659.25 * pitchMultiplier, 783.99 * pitchMultiplier];

            frequencies.forEach((freq, i) => {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(freq, now);

                const startTime = now + i * 0.05;
                const duration = 0.15;

                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.15, startTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

                oscillator.start(startTime);
                oscillator.stop(startTime + duration);
            });

            // Extra sparkle for combos
            if (comboMultiplier > 1) {
                const sparkle = audioCtx.createOscillator();
                const sparkleGain = audioCtx.createGain();
                sparkle.connect(sparkleGain);
                sparkleGain.connect(audioCtx.destination);
                sparkle.type = 'sine';
                sparkle.frequency.setValueAtTime(1318.5 * pitchMultiplier, now);
                sparkleGain.gain.setValueAtTime(0, now + 0.1);
                sparkleGain.gain.linearRampToValueAtTime(0.1, now + 0.12);
                sparkleGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                sparkle.start(now + 0.1);
                sparkle.stop(now + 0.3);
            }
        }

        function playPowerUpSound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;

            // Rising arpeggio
            const notes = [261.63, 329.63, 392.00, 523.25, 659.25];
            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now + i * 0.05);
                gain.gain.setValueAtTime(0, now + i * 0.05);
                gain.gain.linearRampToValueAtTime(0.1, now + i * 0.05 + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.05 + 0.15);
                osc.start(now + i * 0.05);
                osc.stop(now + i * 0.05 + 0.15);
            });
        }

        function playNearMissSound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;

            // Quick whoosh
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        }

        function playLevelCompleteSound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;

            // Triumphant fanfare
            const notes = [392.00, 493.88, 587.33, 783.99];
            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now + i * 0.15);
                gain.gain.setValueAtTime(0, now + i * 0.15);
                gain.gain.linearRampToValueAtTime(0.15, now + i * 0.15 + 0.02);
                gain.gain.setValueAtTime(0.15, now + i * 0.15 + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.15 + 0.3);
                osc.start(now + i * 0.15);
                osc.stop(now + i * 0.15 + 0.3);
            });
        }

        function playCaughtSound() {
            if (!audioCtx) return;

            const now = audioCtx.currentTime;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(400, now);
            oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.5);

            gainNode.gain.setValueAtTime(0.2, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

            oscillator.start(now);
            oscillator.stop(now + 0.5);

            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();

            osc2.connect(gain2);
            gain2.connect(audioCtx.destination);

            osc2.type = 'square';
            osc2.frequency.setValueAtTime(300, now + 0.1);
            osc2.frequency.exponentialRampToValueAtTime(80, now + 0.6);

            gain2.gain.setValueAtTime(0.1, now + 0.1);
            gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.6);

            osc2.start(now + 0.1);
            osc2.stop(now + 0.6);

            const thud = audioCtx.createOscillator();
            const thudGain = audioCtx.createGain();

            thud.connect(thudGain);
            thudGain.connect(audioCtx.destination);

            thud.type = 'sine';
            thud.frequency.setValueAtTime(80, now);
            thud.frequency.exponentialRampToValueAtTime(40, now + 0.3);

            thudGain.gain.setValueAtTime(0.3, now);
            thudGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

            thud.start(now);
            thud.stop(now + 0.3);
        }

        // Screen effects
        let screenShake = { intensity: 0, duration: 0 };
        let screenFlash = { color: null, alpha: 0 };
        let screenZoom = { scale: 1, target: 1 };
        let vignette = { intensity: 0.3 };

        function triggerCaughtEffect(x, y) {
            screenShake.intensity = 15;
            screenShake.duration = 40;

            screenFlash.color = '#e94560';
            screenFlash.alpha = 0.7;

            const colors = ['#e94560', '#ff6b6b', '#ffffff', '#ffd700'];
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 8;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.012 + Math.random() * 0.01,
                    size: 4 + Math.random() * 8,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    type: Math.random() > 0.3 ? 'circle' : 'star'
                });
            }

            for (let i = 0; i < 4; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: 0,
                    vy: 0,
                    life: 1.0,
                    decay: 0.02 + i * 0.008,
                    size: GUARD_SIZE / 2,
                    maxSize: GUARD_SIZE * 4,
                    color: i === 0 ? '#e94560' : i === 1 ? '#ff6b6b' : '#ffffff',
                    type: 'ring'
                });
            }
        }

        function triggerLevelComplete() {
            gameState.levelTransition = true;
            gameState.levelTransitionTimer = 60;
            screenZoom.target = 1.1;
            screenFlash.color = '#ffd700';
            screenFlash.alpha = 0.4;
            playLevelCompleteSound();
            announce(`Level ${gameState.level} complete! Advancing to level ${gameState.level + 1}`);

            // Spawn celebratory particles
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height + 20,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -8 - Math.random() * 6,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.01,
                    size: 3 + Math.random() * 5,
                    color: ['#ffd700', '#e94560', '#4ade80', '#60a5fa'][Math.floor(Math.random() * 4)],
                    type: 'star'
                });
            }
        }

        function updateScreenEffects() {
            if (screenShake.duration > 0) {
                screenShake.duration--;
                screenShake.intensity *= 0.92;
            }

            if (screenFlash.alpha > 0) {
                screenFlash.alpha *= 0.9;
                if (screenFlash.alpha < 0.01) screenFlash.alpha = 0;
            }

            // Smooth zoom
            screenZoom.scale += (screenZoom.target - screenZoom.scale) * 0.1;
            if (Math.abs(screenZoom.scale - screenZoom.target) < 0.001) {
                screenZoom.scale = screenZoom.target;
            }

            // Update vignette based on danger
            vignette.intensity = 0.3 + gameState.dangerLevel * 0.4;
        }

        function applyScreenShake() {
            if (screenShake.duration > 0) {
                const offsetX = (Math.random() - 0.5) * screenShake.intensity * 2;
                const offsetY = (Math.random() - 0.5) * screenShake.intensity * 2;
                ctx.translate(offsetX, offsetY);
            }
        }

        function drawScreenFlash() {
            if (screenFlash.alpha > 0) {
                ctx.fillStyle = screenFlash.color;
                ctx.globalAlpha = screenFlash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
            }
        }

        function drawVignette() {
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.height * 0.3,
                canvas.width / 2, canvas.height / 2, canvas.height * 0.9
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, `rgba(0, 0, 0, ${vignette.intensity})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Particle system
        let particles = [];
        // Speed lines
        let speedLines = [];

        function updateSpeedLines() {
            // Spawn new speed lines when moving fast
            if (!gameState.gameOver && gameState.speed > 2) {
                if (Math.random() < 0.3) {
                    speedLines.push({
                        x: gameState.playerX - 10,
                        y: gameState.playerY + (Math.random() - 0.5) * 20,
                        length: 20 + Math.random() * 30,
                        life: 1.0,
                        decay: 0.08
                    });
                }
            }

            // Update existing
            for (let i = speedLines.length - 1; i >= 0; i--) {
                const line = speedLines[i];
                line.x -= 8;
                line.life -= line.decay;
                if (line.life <= 0 || line.x + line.length < 0) {
                    speedLines.splice(i, 1);
                }
            }
        }

        function drawSpeedLines() {
            ctx.strokeStyle = '#e94560';
            for (const line of speedLines) {
                ctx.globalAlpha = line.life * 0.5;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(line.x, line.y);
                ctx.lineTo(line.x + line.length, line.y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function spawnCollectParticles(x, y) {
            const colors = ['#ffd700', '#ffec8b', '#fff8dc', '#e94560', '#ffffff'];
            const particleCount = 25 + gameState.combo * 5;

            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                const speed = 2 + Math.random() * 5 + gameState.combo;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 4,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    type: Math.random() > 0.5 ? 'circle' : 'star'
                });
            }

            // Multiple rings for combo
            const ringCount = 1 + Math.min(gameState.combo, 3);
            for (let r = 0; r < ringCount; r++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: 0,
                    vy: 0,
                    life: 1.0,
                    decay: 0.03 + r * 0.01,
                    size: ARTWORK_SIZE / 2,
                    maxSize: ARTWORK_SIZE * (1.5 + r * 0.5),
                    color: r === 0 ? '#ffd700' : '#ffffff',
                    type: 'ring'
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= p.decay;

                if (p.type === 'ring') {
                    p.size += (p.maxSize - ARTWORK_SIZE / 2) * p.decay * 2;
                } else {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1;
                    p.vx *= 0.98;
                }

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Update floating texts
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const t = floatingTexts[i];
                t.y += t.vy;
                t.life -= 0.02;
                if (t.life <= 0) {
                    floatingTexts.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            for (const p of particles) {
                ctx.globalAlpha = p.life;

                if (p.type === 'ring') {
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 3 * p.life;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (p.type === 'star') {
                    drawStar(p.x, p.y, p.size, p.color);
                } else {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;

            // Draw floating texts
            ctx.font = 'bold 18px Courier New';
            ctx.textAlign = 'center';
            for (const t of floatingTexts) {
                ctx.globalAlpha = t.life;
                ctx.fillStyle = t.color;
                ctx.fillText(t.text, t.x, t.y);
            }
            ctx.globalAlpha = 1;
        }

        function drawStar(x, y, size, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                const innerAngle = angle + Math.PI / 5;
                if (i === 0) {
                    ctx.moveTo(x + Math.cos(angle) * size, y + Math.sin(angle) * size);
                } else {
                    ctx.lineTo(x + Math.cos(angle) * size, y + Math.sin(angle) * size);
                }
                ctx.lineTo(x + Math.cos(innerAngle) * size * 0.4, y + Math.sin(innerAngle) * size * 0.4);
            }
            ctx.closePath();
            ctx.fill();
        }

        // Toast notification system
        const toastEl = document.getElementById('toast');
        let toastTimeout = null;

        function showToast(artworkData, points) {
            if (toastTimeout) clearTimeout(toastTimeout);

            const titleEl = toastEl.querySelector('.toast-title');
            const artistEl = toastEl.querySelector('.toast-artist');
            const detailsEl = toastEl.querySelector('.toast-details');
            const pointsEl = toastEl.querySelector('.toast-points');

            titleEl.textContent = artworkData.title || 'Untitled';
            artistEl.textContent = artworkData.artist;

            const details = [];
            if (artworkData.date) details.push(artworkData.date);
            if (artworkData.origin) details.push(artworkData.origin);
            if (artworkData.medium) details.push(artworkData.medium);
            detailsEl.textContent = details.join(' ¬∑ ');
            if (artworkData.style) {
                detailsEl.textContent += (details.length ? ' ¬∑ ' : '') + artworkData.style;
            }

            pointsEl.textContent = `+${points} points${gameState.combo > 1 ? ` (${gameState.combo}x combo!)` : ''}`;

            toastEl.classList.add('show');

            toastTimeout = setTimeout(() => {
                toastEl.classList.remove('show');
            }, 2500);
        }

        // Fetch artworks from Art Institute of Chicago API
        async function fetchArtworks() {
            try {
                const randomPage = Math.floor(Math.random() * 10) + 1;
                const response = await fetch(
                    `https://api.artic.edu/api/v1/artworks/search?query[term][is_public_domain]=true&fields=id,title,image_id,artist_display,date_display,medium_display,place_of_origin,style_title&limit=100&page=${randomPage}`
                );
                const data = await response.json();

                artworksByStyle = {};
                for (const art of data.data) {
                    if (!art.image_id || !art.style_title) continue;

                    const style = art.style_title;
                    if (!artworksByStyle[style]) {
                        artworksByStyle[style] = [];
                    }

                    const isLocalDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                    const imageUrl = isLocalDev
                        ? `/iiif/2/${art.image_id}/full/80,/0/default.jpg`
                        : `https://www.artic.edu/iiif/2/${art.image_id}/full/80,/0/default.jpg`;

                    artworksByStyle[style].push({
                        id: art.id,
                        title: art.title,
                        artist: art.artist_display || 'Unknown artist',
                        date: art.date_display || 'Date unknown',
                        medium: art.medium_display || '',
                        origin: art.place_of_origin || '',
                        style: style,
                        imageUrl: imageUrl
                    });
                }

                availableStyles = Object.keys(artworksByStyle)
                    .filter(style => artworksByStyle[style].length >= MIN_ARTWORKS_PER_STYLE);

                console.log(`Loaded ${availableStyles.length} art styles:`, availableStyles);
                gameState.artworksLoaded = true;
            } catch (error) {
                console.error('Failed to fetch artworks:', error);
                gameState.artworksLoaded = true;
            }
        }

        function loadArtworkImage(artwork) {
            return new Promise((resolve) => {
                if (artworkImages[artwork.id]) {
                    resolve(artworkImages[artwork.id]);
                    return;
                }
                const img = new Image();
                const isLocalDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                if (isLocalDev) {
                    img.crossOrigin = 'anonymous';
                }
                img.onload = () => {
                    artworkImages[artwork.id] = img;
                    resolve(img);
                };
                img.onerror = () => {
                    resolve(null);
                };
                img.src = artwork.imageUrl;
            });
        }

        function init() {
            gameState.playerX = 0;
            gameState.playerY = Math.random() * (canvas.height - 100) + 50;
            gameState.path = [{ x: gameState.playerX, y: gameState.playerY }];
            gameState.goingUp = false;
            gameState.gameOver = false;
            gameState.combo = 0;
            gameState.comboTimer = 0;
            gameState.timeScale = 1;
            gameState.slowMoTimer = 0;
            gameState.isInvisible = false;
            gameState.invisibleTimer = 0;
            gameState.hasMagnet = false;
            gameState.magnetTimer = 0;
            gameState.speed = gameState.baseSpeed;
            gameState.levelTransition = false;
            gameState.levelTransitionTimer = 0;
            screenZoom.target = 1;
            gameOverEl.classList.remove('show');
            hideFinishScreen();
            comboDisplayEl.classList.remove('active');

            pickNewStyle();

            spawnGuards(4 + gameState.level);
            spawnArtworks(3 + gameState.level);
            spawnPowerUps();
            spawnLasers();
            updateUI();
        }

        function pickNewStyle() {
            const unusedStyles = availableStyles.filter(s => !gameState.usedStyles.includes(s));

            if (unusedStyles.length === 0) {
                gameState.usedStyles = [];
                unusedStyles.push(...availableStyles);
            }

            if (unusedStyles.length > 0) {
                const randomIndex = Math.floor(Math.random() * unusedStyles.length);
                gameState.currentStyle = unusedStyles[randomIndex];
                gameState.usedStyles.push(gameState.currentStyle);
            } else {
                gameState.currentStyle = null;
            }
        }

        // Guard types
        const GUARD_TYPES = {
            normal: { emoji: 'üëÆ', speed: 1, radius: GUARD_SIZE / 2, color: '#4a90d9' },
            fast: { emoji: 'üèÉ', speed: 2, radius: GUARD_SIZE / 2 - 5, color: '#e94560' },
            stationary: { emoji: 'üî¶', speed: 0, radius: GUARD_SIZE, hasSpotlight: true, color: '#ffd700' }
        };

        function spawnGuards(count) {
            gameState.guards = [];
            const margin = 50;
            const minX = 100;

            for (let i = 0; i < count; i++) {
                let guard;
                let attempts = 0;

                // Determine guard type based on level
                let guardType = 'normal';
                if (gameState.level >= 3 && Math.random() < 0.2) {
                    guardType = 'fast';
                }
                if (gameState.level >= 5 && Math.random() < 0.15) {
                    guardType = 'stationary';
                }

                const typeData = GUARD_TYPES[guardType];

                do {
                    guard = {
                        baseX: minX + Math.random() * (canvas.width - minX - margin),
                        baseY: margin + Math.random() * (canvas.height - margin * 2),
                        x: 0,
                        y: 0,
                        phase: Math.random() * Math.PI * 2,
                        speedX: (0.3 + Math.random() * 0.4) * typeData.speed,
                        speedY: (0.3 + Math.random() * 0.4) * typeData.speed,
                        radiusX: 15 + Math.random() * 20,
                        radiusY: 10 + Math.random() * 15,
                        type: guardType,
                        alertLevel: 0, // 0-1, how alerted they are
                        spotlightAngle: Math.random() * Math.PI * 2
                    };
                    guard.x = guard.baseX;
                    guard.y = guard.baseY;
                    attempts++;
                } while (attempts < 50 && isOverlappingGuard(guard));

                gameState.guards.push(guard);
            }
        }

        function spawnPowerUps() {
            gameState.powerUps = [];
            if (gameState.level < 2) return; // No power-ups on level 1

            const powerUpTypes = ['speed', 'invisible', 'magnet'];
            const count = Math.min(2, Math.floor(gameState.level / 2));

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let powerUp;
                do {
                    powerUp = {
                        x: 150 + Math.random() * (canvas.width - 200),
                        y: 50 + Math.random() * (canvas.height - 100),
                        type: powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)],
                        collected: false,
                        bobPhase: Math.random() * Math.PI * 2
                    };
                    attempts++;
                } while (attempts < 30 && isOverlappingAnything(powerUp));

                gameState.powerUps.push(powerUp);
            }
        }

        function spawnLasers() {
            gameState.lasers = [];
            if (gameState.level < 4) return; // No lasers until level 4

            const count = Math.min(3, Math.floor((gameState.level - 3) / 2));

            for (let i = 0; i < count; i++) {
                const isHorizontal = Math.random() > 0.5;
                gameState.lasers.push({
                    x: 200 + Math.random() * (canvas.width - 400),
                    y: 100 + Math.random() * (canvas.height - 200),
                    isHorizontal: isHorizontal,
                    length: 80 + Math.random() * 60,
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.02 + Math.random() * 0.02
                });
            }
        }

        function isOverlappingAnything(obj) {
            // Check guards
            for (const guard of gameState.guards) {
                const dx = obj.x - (guard.baseX || guard.x);
                const dy = obj.y - (guard.baseY || guard.y);
                if (Math.sqrt(dx * dx + dy * dy) < GUARD_SIZE * 2) return true;
            }
            // Check artworks
            for (const art of gameState.artworks) {
                const dx = obj.x - art.x;
                const dy = obj.y - art.y;
                if (Math.sqrt(dx * dx + dy * dy) < ARTWORK_SIZE * 1.5) return true;
            }
            return false;
        }

        function updateGuards() {
            const time = Date.now() / 1000;
            let closestDistance = Infinity;

            for (const guard of gameState.guards) {
                const typeData = GUARD_TYPES[guard.type];

                // Calculate distance to player
                const dx = gameState.playerX - guard.x;
                const dy = gameState.playerY - guard.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                closestDistance = Math.min(closestDistance, dist);

                // Update alert level
                const alertDist = 120;
                if (dist < alertDist && !gameState.isInvisible) {
                    guard.alertLevel = Math.min(1, guard.alertLevel + 0.04);
                } else {
                    guard.alertLevel = Math.max(0, guard.alertLevel - 0.015);
                }

                // Normal patrol movement
                if (typeData.speed > 0) {
                    const patrolX = guard.baseX + Math.sin(time * guard.speedX + guard.phase) * guard.radiusX;
                    const patrolY = guard.baseY + Math.cos(time * guard.speedY + guard.phase) * guard.radiusY;

                    // When alerted, blend patrol with pursuit
                    if (guard.alertLevel > 0.3 && !gameState.isInvisible && dist > 0) {
                        // Chase speed increases with alert level (kept slow to be fair)
                        const chaseStrength = (guard.alertLevel - 0.3) * 1.5; // 0 to ~1
                        const chaseSpeed = 0.4 + chaseStrength * 0.5;

                        // Move toward player
                        const chaseX = guard.x + (dx / dist) * chaseSpeed;
                        const chaseY = guard.y + (dy / dist) * chaseSpeed;

                        // Blend between patrol and chase based on alert level
                        const blendFactor = Math.min(1, chaseStrength);
                        guard.x = patrolX * (1 - blendFactor) + chaseX * blendFactor;
                        guard.y = patrolY * (1 - blendFactor) + chaseY * blendFactor;
                    } else {
                        guard.x = patrolX;
                        guard.y = patrolY;
                    }
                } else {
                    // Stationary spotlight guards
                    guard.x = guard.baseX;
                    guard.y = guard.baseY;

                    // Rotate spotlight - faster when alerted, and track toward player
                    if (guard.alertLevel > 0.5 && !gameState.isInvisible) {
                        // Turn spotlight toward player
                        const targetAngle = Math.atan2(dy, dx);
                        let angleDiff = targetAngle - guard.spotlightAngle;
                        // Normalize angle difference
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        guard.spotlightAngle += angleDiff * 0.05 * guard.alertLevel;
                    } else {
                        guard.spotlightAngle += 0.02;
                    }
                }

                // Keep guards within bounds (but allow them to leave their base area when chasing)
                guard.x = Math.max(GUARD_SIZE, Math.min(canvas.width - GUARD_SIZE, guard.x));
                guard.y = Math.max(GUARD_SIZE, Math.min(canvas.height - GUARD_SIZE, guard.y));
            }

            // Update danger level for heartbeat
            gameState.dangerLevel = Math.max(0, 1 - closestDistance / 150);
        }

        function updateLasers() {
            for (const laser of gameState.lasers) {
                laser.phase += laser.speed;
            }
        }

        function isOverlappingGuard(newGuard) {
            for (const guard of gameState.guards) {
                const gx = guard.baseX || guard.x;
                const gy = guard.baseY || guard.y;
                const nx = newGuard.baseX || newGuard.x;
                const ny = newGuard.baseY || newGuard.y;
                const dx = nx - gx;
                const dy = ny - gy;
                if (Math.sqrt(dx * dx + dy * dy) < GUARD_SIZE * 3) {
                    return true;
                }
            }
            return false;
        }

        function spawnArtworks(count) {
            gameState.artworks = [];
            const margin = 50;
            const minX = 80;

            const styleArtworks = gameState.currentStyle
                ? artworksByStyle[gameState.currentStyle] || []
                : [];

            const shuffled = [...styleArtworks].sort(() => Math.random() - 0.5);

            for (let i = 0; i < count; i++) {
                let artwork;
                let attempts = 0;

                do {
                    artwork = {
                        x: minX + Math.random() * (canvas.width - minX - margin),
                        y: margin + Math.random() * (canvas.height - margin * 2),
                        collected: false,
                        glowPhase: Math.random() * Math.PI * 2
                    };
                    attempts++;
                } while (attempts < 50 && (isOverlappingGuard(artwork) || isOverlappingArtwork(artwork)));

                if (shuffled.length > 0) {
                    const artData = shuffled[i % shuffled.length];
                    artwork.data = artData;
                    loadArtworkImage(artData);
                }

                gameState.artworks.push(artwork);
            }
        }

        function isOverlappingArtwork(newArtwork) {
            for (const art of gameState.artworks) {
                const dx = newArtwork.x - art.x;
                const dy = newArtwork.y - art.y;
                if (Math.sqrt(dx * dx + dy * dy) < ARTWORK_SIZE * 1.5) {
                    return true;
                }
            }
            for (const guard of gameState.guards) {
                const gx = guard.baseX || guard.x;
                const gy = guard.baseY || guard.y;
                const dx = newArtwork.x - gx;
                const dy = newArtwork.y - gy;
                const guardRadius = Math.max(guard.radiusX || 0, guard.radiusY || 0);
                if (Math.sqrt(dx * dx + dy * dy) < ARTWORK_SIZE + GUARD_SIZE + guardRadius) {
                    return true;
                }
            }
            return false;
        }

        function updateUI() {
            levelEl.textContent = gameState.level;
            scoreEl.textContent = gameState.score;
            themeEl.textContent = gameState.currentStyle || 'Mixed';
        }

        function showFinishScreen() {
            document.getElementById('finish-level').textContent = gameState.level;
            document.getElementById('finish-count').textContent = gameState.stolenArtworks.length;
            document.getElementById('finish-score').textContent = gameState.score;

            const isNewHighScore = updateHighScore(gameState.score);
            document.getElementById('new-high-score').style.display = isNewHighScore ? 'block' : 'none';

            const lootGrid = document.getElementById('loot-grid');
            lootGrid.innerHTML = '';

            if (gameState.stolenArtworks.length === 0) {
                lootGrid.innerHTML = '<div class="no-loot">No artworks stolen... maybe next time!</div>';
            } else {
                for (const art of gameState.stolenArtworks) {
                    const item = document.createElement('div');
                    item.className = 'loot-item';
                    item.setAttribute('role', 'listitem');

                    const img = artworkImages[art.id];
                    const artUrl = `https://www.artic.edu/artworks/${art.id}`;
                    const altText = `${art.title || 'Untitled'} by ${art.artist}`;

                    let imageHtml;
                    if (img) {
                        imageHtml = `<img class="loot-image" src="${art.imageUrl}" alt="">`;
                    } else {
                        imageHtml = `<div class="loot-image-placeholder" aria-hidden="true">ART</div>`;
                    }

                    const details = [];
                    if (art.date) details.push(art.date);
                    if (art.origin) details.push(art.origin);
                    if (art.medium) details.push(art.medium);

                    // Escape HTML entities to prevent XSS
                    const escapeHtml = (str) => str ? str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') : '';

                    item.innerHTML = `
                        <a href="${artUrl}" target="_blank" rel="noopener noreferrer" class="loot-link" aria-label="${escapeHtml(altText)} - View on Art Institute of Chicago website">
                            ${imageHtml}
                            <div class="loot-info">
                                <h3 class="loot-title">${escapeHtml(art.title) || 'Untitled'}</h3>
                                <p class="loot-artist">${escapeHtml(art.artist)}</p>
                                <p class="loot-details">${escapeHtml(details.join(' ¬∑ '))}</p>
                                <p class="loot-style">${escapeHtml(art.style) || ''}</p>
                            </div>
                        </a>
                    `;

                    lootGrid.appendChild(item);
                }
            }

            finishScreenEl.classList.add('show');
            announce(`Game over. You reached level ${gameState.level} and scored ${gameState.score} points.${isNewHighScore ? ' New high score!' : ''}`);
        }

        function hideFinishScreen() {
            finishScreenEl.classList.remove('show');
        }

        function update() {
            updateParticles();
            updateScreenEffects();
            updateSpeedLines();

            // Handle level transition
            if (gameState.levelTransition) {
                gameState.levelTransitionTimer--;
                if (gameState.levelTransitionTimer <= 0) {
                    gameState.levelTransition = false;
                    gameState.level++;
                    gameState.score += 100;
                    init();
                }
                return;
            }

            if (gameState.gameOver) return;

            // Update time scale (slow-mo effect)
            if (gameState.slowMoTimer > 0) {
                gameState.slowMoTimer--;
                gameState.timeScale = 0.3;
            } else {
                gameState.timeScale = Math.min(1, gameState.timeScale + 0.05);
            }

            // Update power-up timers
            if (gameState.invisibleTimer > 0) {
                gameState.invisibleTimer--;
                if (gameState.invisibleTimer <= 0) gameState.isInvisible = false;
            }
            if (gameState.magnetTimer > 0) {
                gameState.magnetTimer--;
                if (gameState.magnetTimer <= 0) gameState.hasMagnet = false;
            }

            // Update combo timer
            if (gameState.combo > 0) {
                const timeSinceCollect = Date.now() - gameState.lastCollectTime;
                if (timeSinceCollect > COMBO_WINDOW) {
                    gameState.combo = 0;
                    comboDisplayEl.classList.remove('active');
                }
            }

            updateGuards();
            updateLasers();
            updateHeartbeat();

            // Move player (affected by time scale)
            const effectiveSpeed = gameState.speed * gameState.timeScale;
            const angle = gameState.goingUp ? -Math.PI / 4 : Math.PI / 4;
            gameState.playerX += Math.cos(angle) * effectiveSpeed;
            gameState.playerY += Math.sin(angle) * effectiveSpeed;

            // Wrap around top/bottom
            if (gameState.playerY < 0) {
                gameState.path.push({ x: gameState.playerX, y: 0 });
                gameState.playerY = canvas.height;
                gameState.path.push({ x: gameState.playerX, y: canvas.height, newSegment: true });
            } else if (gameState.playerY > canvas.height) {
                gameState.path.push({ x: gameState.playerX, y: canvas.height });
                gameState.playerY = 0;
                gameState.path.push({ x: gameState.playerX, y: 0, newSegment: true });
            }

            gameState.path.push({ x: gameState.playerX, y: gameState.playerY });

            // Magnet effect - attract nearby artworks
            if (gameState.hasMagnet) {
                for (const artwork of gameState.artworks) {
                    if (artwork.collected) continue;
                    const dx = gameState.playerX - artwork.x;
                    const dy = gameState.playerY - artwork.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 150 && dist > 0) {
                        artwork.x += dx / dist * 2;
                        artwork.y += dy / dist * 2;
                    }
                }
            }

            // Check collision with power-ups
            for (const powerUp of gameState.powerUps) {
                if (powerUp.collected) continue;
                const dx = gameState.playerX - powerUp.x;
                const dy = gameState.playerY - powerUp.y;
                if (Math.sqrt(dx * dx + dy * dy) < POWER_UP_SIZE + 5) {
                    powerUp.collected = true;
                    playPowerUpSound();
                    applyPowerUp(powerUp.type);
                    spawnCollectParticles(powerUp.x, powerUp.y);
                }
            }

            // Check collision with artworks (box collision for better edge detection)
            for (const artwork of gameState.artworks) {
                if (artwork.collected) continue;
                const halfSize = ARTWORK_SIZE / 2 + 8; // Slightly generous hitbox
                const dx = Math.abs(gameState.playerX - artwork.x);
                const dy = Math.abs(gameState.playerY - artwork.y);
                if (dx < halfSize && dy < halfSize) {
                    artwork.collected = true;

                    // Update combo
                    gameState.combo++;
                    gameState.lastCollectTime = Date.now();

                    // Calculate points with combo multiplier
                    const comboMultiplier = Math.min(gameState.combo, 5);
                    const points = 50 * comboMultiplier;
                    gameState.score += points;

                    // Show combo
                    if (gameState.combo > 1) {
                        comboCountEl.textContent = gameState.combo;
                        comboDisplayEl.classList.add('active');
                    }

                    updateUI();
                    spawnCollectParticles(artwork.x, artwork.y);
                    spawnFloatingText(artwork.x, artwork.y - 30, `+${points}`, gameState.combo > 1 ? '#ff6b6b' : '#ffd700');
                    playCollectSound(comboMultiplier);

                    if (artwork.data) {
                        gameState.stolenArtworks.push(artwork.data);
                        showToast(artwork.data, points);
                        announce(`Collected ${artwork.data.title || 'artwork'} for ${points} points`);
                    }
                }
            }

            // Check collision with guards (unless invisible)
            if (!gameState.isInvisible) {
                for (const guard of gameState.guards) {
                    const typeData = GUARD_TYPES[guard.type];
                    const dx = gameState.playerX - guard.x;
                    const dy = gameState.playerY - guard.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Check spotlight for stationary guards
                    if (typeData.hasSpotlight) {
                        const angleToPlayer = Math.atan2(dy, dx);
                        const angleDiff = Math.abs(angleToPlayer - guard.spotlightAngle);
                        const normalizedAngleDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);
                        if (dist < 100 && normalizedAngleDiff < 0.5) {
                            gameState.gameOver = true;
                            triggerCaughtEffect(gameState.playerX, gameState.playerY);
                            playCaughtSound();
                            setTimeout(showFinishScreen, 800);
                            return;
                        }
                    }

                    if (dist < typeData.radius + 5) {
                        gameState.gameOver = true;
                        triggerCaughtEffect(gameState.playerX, gameState.playerY);
                        playCaughtSound();
                        setTimeout(showFinishScreen, 800);
                        return;
                    }

                    // Near miss detection
                    if (dist < typeData.radius + 25 && dist >= typeData.radius + 5) {
                        if (gameState.nearMissTimer <= 0) {
                            gameState.nearMissTimer = 30;
                            gameState.slowMoTimer = 15; // Brief slow-mo
                            playNearMissSound();
                            spawnFloatingText(gameState.playerX, gameState.playerY - 20, 'CLOSE!', '#ff6b6b');
                            screenShake.intensity = 3;
                            screenShake.duration = 10;
                        }
                    }
                }
                if (gameState.nearMissTimer > 0) gameState.nearMissTimer--;
            }

            // Check collision with lasers
            for (const laser of gameState.lasers) {
                const active = Math.sin(laser.phase) > 0;
                if (!active) continue;

                let hit = false;
                if (laser.isHorizontal) {
                    if (Math.abs(gameState.playerY - laser.y) < 5 &&
                        gameState.playerX > laser.x - laser.length / 2 &&
                        gameState.playerX < laser.x + laser.length / 2) {
                        hit = true;
                    }
                } else {
                    if (Math.abs(gameState.playerX - laser.x) < 5 &&
                        gameState.playerY > laser.y - laser.length / 2 &&
                        gameState.playerY < laser.y + laser.length / 2) {
                        hit = true;
                    }
                }

                if (hit && !gameState.isInvisible) {
                    gameState.gameOver = true;
                    triggerCaughtEffect(gameState.playerX, gameState.playerY);
                    playCaughtSound();
                    setTimeout(showFinishScreen, 800);
                    return;
                }
            }

            // Check if reached right side
            if (gameState.playerX >= canvas.width) {
                triggerLevelComplete();
            }
        }

        function applyPowerUp(type) {
            switch (type) {
                case 'speed':
                    gameState.speed = gameState.baseSpeed * 1.5;
                    setTimeout(() => { gameState.speed = gameState.baseSpeed; }, 5000);
                    spawnFloatingText(gameState.playerX, gameState.playerY - 30, 'SPEED!', '#4ade80');
                    announce('Speed boost activated!');
                    break;
                case 'invisible':
                    gameState.isInvisible = true;
                    gameState.invisibleTimer = 180; // 3 seconds at 60fps
                    spawnFloatingText(gameState.playerX, gameState.playerY - 30, 'INVISIBLE!', '#60a5fa');
                    announce('Invisibility activated!');
                    break;
                case 'magnet':
                    gameState.hasMagnet = true;
                    gameState.magnetTimer = 300; // 5 seconds at 60fps
                    spawnFloatingText(gameState.playerX, gameState.playerY - 30, 'MAGNET!', '#f472b6');
                    announce('Art magnet activated!');
                    break;
            }
        }

        // Parallax background layers
        const bgLayers = [
            { offset: 0, speed: 0.1, color: '#0a0a15' },
            { offset: 0, speed: 0.2, color: '#0f0f1f' },
            { offset: 0, speed: 0.3, color: '#141428' }
        ];

        function drawBackground() {
            // Update parallax
            for (const layer of bgLayers) {
                layer.offset -= layer.speed;
                if (layer.offset < -50) layer.offset = 0;
            }

            // Base background
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Parallax grid layers
            for (const layer of bgLayers) {
                ctx.strokeStyle = layer.color;
                ctx.lineWidth = 1;
                for (let x = layer.offset; x < canvas.width; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
        }

        function draw() {
            ctx.save();

            // Apply zoom
            if (screenZoom.scale !== 1) {
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(screenZoom.scale, screenZoom.scale);
                ctx.translate(-canvas.width / 2, -canvas.height / 2);
            }

            applyScreenShake();

            drawBackground();

            // Draw lasers
            for (const laser of gameState.lasers) {
                const active = Math.sin(laser.phase) > 0;
                const warning = Math.sin(laser.phase) > -0.3 && Math.sin(laser.phase) < 0;

                if (active) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 15;
                } else if (warning) {
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 0;
                } else {
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.shadowBlur = 0;
                }

                ctx.beginPath();
                if (laser.isHorizontal) {
                    ctx.moveTo(laser.x - laser.length / 2, laser.y);
                    ctx.lineTo(laser.x + laser.length / 2, laser.y);
                } else {
                    ctx.moveTo(laser.x, laser.y - laser.length / 2);
                    ctx.lineTo(laser.x, laser.y + laser.length / 2);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Draw power-ups
            const time = Date.now() / 1000;
            for (const powerUp of gameState.powerUps) {
                if (powerUp.collected) continue;

                const bobY = Math.sin(time * 3 + powerUp.bobPhase) * 5;
                const x = powerUp.x;
                const y = powerUp.y + bobY;

                // Glow
                ctx.shadowColor = powerUp.type === 'speed' ? '#4ade80' :
                                  powerUp.type === 'invisible' ? '#60a5fa' : '#f472b6';
                ctx.shadowBlur = 15;

                ctx.fillStyle = ctx.shadowColor;
                ctx.beginPath();
                ctx.arc(x, y, POWER_UP_SIZE, 0, Math.PI * 2);
                ctx.fill();

                // Icon
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const icon = powerUp.type === 'speed' ? '‚ö°' :
                            powerUp.type === 'invisible' ? 'üëª' : 'üß≤';
                ctx.fillText(icon, x, y);
                ctx.shadowBlur = 0;
            }

            // Draw artworks with proximity glow
            for (const artwork of gameState.artworks) {
                if (artwork.collected) continue;

                const dx = gameState.playerX - artwork.x;
                const dy = gameState.playerY - artwork.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const proximityGlow = Math.max(0, 1 - dist / 150);

                artwork.glowPhase += 0.05;

                // Dynamic glow based on proximity
                if (proximityGlow > 0) {
                    const glowIntensity = proximityGlow * (0.5 + Math.sin(artwork.glowPhase) * 0.2);
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 20 * glowIntensity;
                }

                const img = artwork.data ? artworkImages[artwork.data.id] : null;
                if (img) {
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 3 + proximityGlow * 2;
                    ctx.strokeRect(
                        artwork.x - ARTWORK_SIZE / 2 - 2,
                        artwork.y - ARTWORK_SIZE / 2 - 2,
                        ARTWORK_SIZE + 4,
                        ARTWORK_SIZE + 4
                    );
                    ctx.drawImage(
                        img,
                        artwork.x - ARTWORK_SIZE / 2,
                        artwork.y - ARTWORK_SIZE / 2,
                        ARTWORK_SIZE,
                        ARTWORK_SIZE
                    );
                } else {
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(
                        artwork.x - ARTWORK_SIZE / 2,
                        artwork.y - ARTWORK_SIZE / 2,
                        ARTWORK_SIZE,
                        ARTWORK_SIZE
                    );
                    ctx.fillStyle = '#16213e';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ART', artwork.x, artwork.y);
                }
                ctx.shadowBlur = 0;
            }

            // Draw guards with vision cones and alert states
            for (const guard of gameState.guards) {
                const typeData = GUARD_TYPES[guard.type];

                // Vision cone for spotlight guards
                if (typeData.hasSpotlight) {
                    ctx.fillStyle = `rgba(255, 215, 0, ${0.1 + guard.alertLevel * 0.2})`;
                    ctx.beginPath();
                    ctx.moveTo(guard.x, guard.y);
                    ctx.arc(guard.x, guard.y, 100, guard.spotlightAngle - 0.5, guard.spotlightAngle + 0.5);
                    ctx.closePath();
                    ctx.fill();
                }

                // Alert indicator
                if (guard.alertLevel > 0.3) {
                    ctx.fillStyle = `rgba(233, 69, 96, ${guard.alertLevel})`;
                    ctx.beginPath();
                    ctx.arc(guard.x, guard.y - GUARD_SIZE, 8 + guard.alertLevel * 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Exclamation mark
                    if (guard.alertLevel > 0.7) {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('!', guard.x, guard.y - GUARD_SIZE);
                    }
                }

                // Guard emoji/icon
                ctx.font = `${GUARD_SIZE}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Red tint when alerted
                if (guard.alertLevel > 0.5) {
                    ctx.shadowColor = '#e94560';
                    ctx.shadowBlur = 10 * guard.alertLevel;
                }

                ctx.fillText(typeData.emoji, guard.x, guard.y);
                ctx.shadowBlur = 0;
            }

            // Draw speed lines
            drawSpeedLines();

            // Draw path with neon glow effect
            if (gameState.path.length > 1) {
                // Outer glow
                ctx.strokeStyle = 'rgba(233, 69, 96, 0.3)';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowColor = '#e94560';
                ctx.shadowBlur = 15;

                ctx.beginPath();
                ctx.moveTo(gameState.path[0].x, gameState.path[0].y);

                for (let i = 1; i < gameState.path.length; i++) {
                    if (gameState.path[i].newSegment) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(gameState.path[i].x, gameState.path[i].y);
                    } else {
                        ctx.lineTo(gameState.path[i].x, gameState.path[i].y);
                    }
                }
                ctx.stroke();

                // Inner bright line
                ctx.strokeStyle = '#e94560';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 0;

                ctx.beginPath();
                ctx.moveTo(gameState.path[0].x, gameState.path[0].y);

                for (let i = 1; i < gameState.path.length; i++) {
                    if (gameState.path[i].newSegment) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(gameState.path[i].x, gameState.path[i].y);
                    } else {
                        ctx.lineTo(gameState.path[i].x, gameState.path[i].y);
                    }
                }
                ctx.stroke();
            }

            // Draw player with pulsing effect
            const pulseSize = 6 + Math.sin(Date.now() / 100) * 1.5;
            const playerAlpha = gameState.isInvisible ? 0.3 : 1;

            ctx.globalAlpha = playerAlpha;

            // Outer glow
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(gameState.playerX, gameState.playerY, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Direction indicator
            const dirAngle = gameState.goingUp ? -Math.PI / 4 : Math.PI / 4;
            const indicatorLength = 15;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(gameState.playerX, gameState.playerY);
            ctx.lineTo(
                gameState.playerX + Math.cos(dirAngle) * indicatorLength,
                gameState.playerY + Math.sin(dirAngle) * indicatorLength
            );
            ctx.stroke();

            ctx.globalAlpha = 1;

            // Draw vignette
            drawVignette();

            // Draw screen flash
            drawScreenFlash();

            // Draw particles on top
            drawParticles();

            ctx.restore();
        }

        function gameLoop() {
            if (gameState.gameStarted) {
                update();
                draw();
            }
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            initAudio();

            if (e.code === 'Space') {
                e.preventDefault();

                // Start game from title screen
                if (!gameState.gameStarted) {
                    gameState.gameStarted = true;
                    titleScreenEl.classList.add('hidden');
                    canvas.focus();
                    startBackgroundMusic();
                    init();
                    announce('Game started. Hold spacebar to go up, release to go down.');
                    return;
                }

                gameState.goingUp = true;
            }

            if (e.code === 'KeyR') {
                if (!gameState.gameStarted) {
                    gameState.gameStarted = true;
                    titleScreenEl.classList.add('hidden');
                    canvas.focus();
                    startBackgroundMusic();
                }
                gameState.level = 1;
                gameState.score = 0;
                gameState.usedStyles = [];
                gameState.stolenArtworks = [];
                gameState.combo = 0;
                particles = [];
                floatingTexts = [];
                speedLines = [];
                screenShake = { intensity: 0, duration: 0 };
                screenFlash = { color: null, alpha: 0 };
                screenZoom = { scale: 1, target: 1 };
                comboDisplayEl.classList.remove('active');
                hideFinishScreen();
                init();
                announce('Game restarted.');
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                gameState.goingUp = false;
            }
        });

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
            }
        });

        // Start loading
        async function startGame() {
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '24px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Loading artworks...', canvas.width / 2, canvas.height / 2);

            await fetchArtworks();
            gameLoop();
        }

        startGame();
    </script>
</body>
</html>
